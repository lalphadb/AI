AI ORCHESTRATOR – AUDIT TECHNIQUE (TX3)
Date: 2025-12-25

1. Méthodologie
- Lecture complète de la structure (`backend`, `frontend`, `docs`, `docker-compose*`, `start.sh`, `nginx.conf`).
- Inspection approfondie des modules critiques (authentification, sécurité, outils système/Docker, moteur ReAct, mémoire, frontend WebSocket).
- Vérification rapide des artefacts sensibles présents dans le dépôt (venv, fichiers .env, backups).
- Tentative d’exécution de la suite de tests via l’environnement embarqué (`backend/venv/bin/python -m pytest tests -q`).

2. Résumé des problèmes (classés par gravité)
A. CRITIQUES
1) Refresh tokens et scopes admin par défaut (`backend/main.py:600-666`).
   - `create_refresh_token` est appelé avec `user_id=1` pour tous les utilisateurs.
   - L’endpoint `/api/auth/refresh` accepte un simple paramètre string, recharge systématiquement `get_user("admin")` et renvoie ses scopes.
   - Conséquence: toute session rafraîchie devient administrateur; les non-admin ne peuvent pas conserver leurs scopes.
   - Documentation/front attendent un corps JSON, donc l’API renvoie aussi une erreur 422/501 en pratique.

2) Couche sécurité non appliquée à la majorité des outils (`backend/tools/__init__.py:33-89`).
   - Seuls `execute_command`, `read_file`, `write_file` reçoivent `security_validator` et `audit_logger`.
   - Les handlers Docker (`backend/tools/docker_tools.py:33-153`), services (`system_tools.py:33-101`), Git, réseau, mémoire exécutent directement `docker`, `systemctl`, `git`, parfois avec `sudo`.
   - Impact: un utilisateur authentifié peut exécuter des commandes critiques hors whitelist, ce qui annule la promesse “zéro shell injection”.

B. ÉLEVÉES
3) Commandes incompatibles avec `run_command_async` (`backend/utils/async_subprocess.py:33-84`).
   - L’exécuteur utilise `execve` sans shell, mais les outils continuent d’employer `|`, `&&`, redirections et `cd &&`.
   - Exemples: `system_info` (pipes), `disk_usage` (`du … | sort`), `list_directory` (`tree … || find`), `docker_logs` (`2>&1`), `docker_compose` (`cd … && docker compose …`), `network_tools.port_scan` (`nmap ... || nc ...`).
   - Résultat: la plupart des commandes échouent silencieusement → pas de stats fiables, risques de comportements inattendus.

4) Frontend WebSocket / API désalignés (`frontend/index.html:269-357` vs `backend/main.py:901-1015`).
   - `conversation_id` n’est jamais stocké car l’évènement `conversation_created` n’est pas géré → chaque message crée une nouvelle conversation.
   - `loadConversations()` suppose que l’API renvoie un tableau, alors que c’est `{ "conversations": [...] }` → liste vide.
   - Le panneau Docker appelle `/api/docker/status` inexistant.
   - Les fichiers sont envoyés inline (`files: attachedFiles`) alors que le backend attend `file_ids` suite à `/api/upload`.
   - Impact: UI inutilisable en conditions réelles (pas d’historique, pas d’upload, pas d’info Docker).

5) Déploiement dangereux et mémoire inopérante (`docker-compose.yml:1-40`, `docker-compose.simple.yml:1-28`).
   - Le conteneur backend monte `/home/lalpha` en lecture/écriture → exposition complète des clés, scripts, secrets.
   - Aucun service ChromaDB n’est défini alors que `auto_learn` et `memory_*` s’y connectent d’office (`backend/auto_learn.py:53-63`, `backend/tools/memory_tools.py:27-52`).
   - Impact: fuite potentielle de données sensibles + fonctionnalités mémoire toujours en erreur.

C. MOYENNES
6) Outil vision inutilisable (`backend/tools/ai_tools.py:23-73`).
   - `uploaded_files` est traité comme un dict; `main.py` lui fournit une liste d’objets (issue: `AttributeError`).

7) Suppressions incomplètes d’uploads (`backend/main.py:473-481`).
   - `delete_conversation` efface les entrées DB mais pas les fichiers physiques dans `data/uploads`, ce qui contrevient au RGPD/droit à l’oubli.
   - Les logs de suppression ne sont pas consignés dans l’audit log.

8) fuite partielle du secret JWT (`backend/auth.py:26-35`).
   - Le module imprime `SECRET_KEY` (début) à chaque démarrage.

9) Config mémoire rigide (`backend/auto_learn.py:53-63`, `memory_tools.py:27-52`).
   - Host/port codés en dur (`chromadb:8000`). Impossible de l’utiliser en local sans éditer le code.

10) Hygiène du dépôt (`backend/.env`, `backend/venv`, multiples backups). Risques de fuite + difficultés de reproduction.

3. Tests
- Commande exécutée : `backend/venv/bin/python -m pytest tests -q`.
- Résultat : `ModuleNotFoundError: No module named 'pytest'` (le venv versionné n’inclut pas les dépendances de test).
- Conséquence : aucune validation automatisée possible sans recréer l’environnement (`pip install -r requirements.txt && pip install pytest pytest-asyncio ...`).

4. Recommandations prioritaires
(1) Réparer l’authentification (stockage `user_id`, endpoints JSON, respect des scopes, suppression du log de secret). Ajouter des tests.
(2) Propager `security_validator`/`audit_log` dans tous les handlers, supprimer `sudo`, vérifier les services/containers autorisés.
(3) Rendre les commandes compatibles avec l’exécuteur (décomposer les pipes ou introduire un shell sécurisé validé). Couvrir ces cas via tests.
(4) Corriger le frontend/WS : gérer `conversation_created`, adapter `loadConversations`, exposer un endpoint Docker ou retirer l’UI, uploader via `/api/upload`.
(5) Ajuster le déploiement : ne plus monter `/home/lalpha` en rw, ajouter un service ChromaDB (ou rendre l’hôte configurable), documenter les secrets.
(6) Nettoyer le dépôt (supprimer `backend/venv`, `.env`, backups), fournir seulement `requirements*.txt` et `.env.example`, mettre en place une CI avec `pytest`.
(7) Supprimer les fichiers d’upload lors d’une suppression de conversation et journaliser l’opération.

