UP035 `typing.Dict` is deprecated, use `dict` instead
  --> ai-orchestrator/backend/auth.py:12:1
   |
10 | import sqlite3
11 | from datetime import datetime, timedelta
12 | from typing import Dict, List, Optional
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
13 |
14 | import jwt
   |

UP035 `typing.List` is deprecated, use `list` instead
  --> ai-orchestrator/backend/auth.py:12:1
   |
10 | import sqlite3
11 | from datetime import datetime, timedelta
12 | from typing import Dict, List, Optional
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
13 |
14 | import jwt
   |

S105 Possible hardcoded password assigned to: "token_type"
  --> ai-orchestrator/backend/auth.py:52:23
   |
50 |     access_token: str
51 |     refresh_token: str
52 |     token_type: str = "bearer"
   |                       ^^^^^^^^
53 |     expires_in: int
   |

UP045 [*] Use `X | None` for type annotations
  --> ai-orchestrator/backend/auth.py:57:15
   |
56 | class TokenData(BaseModel):
57 |     username: Optional[str] = None
   |               ^^^^^^^^^^^^^
58 |     scopes: List[str] = []
   |
help: Convert to `X | None`

UP006 [*] Use `list` instead of `List` for type annotation
  --> ai-orchestrator/backend/auth.py:58:13
   |
56 | class TokenData(BaseModel):
57 |     username: Optional[str] = None
58 |     scopes: List[str] = []
   |             ^^^^
   |
help: Replace with `list`

UP045 [*] Use `X | None` for type annotations
  --> ai-orchestrator/backend/auth.py:63:12
   |
61 | class User(BaseModel):
62 |     username: str
63 |     email: Optional[str] = None
   |            ^^^^^^^^^^^^^
64 |     full_name: Optional[str] = None
65 |     disabled: bool = False
   |
help: Convert to `X | None`

UP045 [*] Use `X | None` for type annotations
  --> ai-orchestrator/backend/auth.py:64:16
   |
62 |     username: str
63 |     email: Optional[str] = None
64 |     full_name: Optional[str] = None
   |                ^^^^^^^^^^^^^
65 |     disabled: bool = False
66 |     is_admin: bool = False
   |
help: Convert to `X | None`

UP006 [*] Use `list` instead of `List` for type annotation
  --> ai-orchestrator/backend/auth.py:67:13
   |
65 |     disabled: bool = False
66 |     is_admin: bool = False
67 |     scopes: List[str] = []
   |             ^^^^
   |
help: Replace with `list`

UP045 [*] Use `X | None` for type annotations
  --> ai-orchestrator/backend/auth.py:77:12
   |
75 |     username: str
76 |     password: str
77 |     email: Optional[str] = None
   |            ^^^^^^^^^^^^^
78 |     full_name: Optional[str] = None
   |
help: Convert to `X | None`

UP045 [*] Use `X | None` for type annotations
  --> ai-orchestrator/backend/auth.py:78:16
   |
76 |     password: str
77 |     email: Optional[str] = None
78 |     full_name: Optional[str] = None
   |                ^^^^^^^^^^^^^
   |
help: Convert to `X | None`

UP045 [*] Use `X | None` for type annotations
  --> ai-orchestrator/backend/auth.py:82:12
   |
81 | class UserUpdate(BaseModel):
82 |     email: Optional[str] = None
   |            ^^^^^^^^^^^^^
83 |     full_name: Optional[str] = None
84 |     password: Optional[str] = None
   |
help: Convert to `X | None`

UP045 [*] Use `X | None` for type annotations
  --> ai-orchestrator/backend/auth.py:83:16
   |
81 | class UserUpdate(BaseModel):
82 |     email: Optional[str] = None
83 |     full_name: Optional[str] = None
   |                ^^^^^^^^^^^^^
84 |     password: Optional[str] = None
   |
help: Convert to `X | None`

UP045 [*] Use `X | None` for type annotations
  --> ai-orchestrator/backend/auth.py:84:15
   |
82 |     email: Optional[str] = None
83 |     full_name: Optional[str] = None
84 |     password: Optional[str] = None
   |               ^^^^^^^^^^^^^
   |
help: Convert to `X | None`

UP006 [*] Use `list` instead of `List` for type annotation
  --> ai-orchestrator/backend/auth.py:90:13
   |
88 |     key: str
89 |     name: str
90 |     scopes: List[str]
   |             ^^^^
91 |     created_at: datetime
92 |     expires_at: Optional[datetime] = None
   |
help: Replace with `list`

UP045 [*] Use `X | None` for type annotations
  --> ai-orchestrator/backend/auth.py:92:17
   |
90 |     scopes: List[str]
91 |     created_at: datetime
92 |     expires_at: Optional[datetime] = None
   |                 ^^^^^^^^^^^^^^^^^^
   |
help: Convert to `X | None`

UP045 [*] Use `X | None` for type annotations
   --> ai-orchestrator/backend/auth.py:218:32
    |
218 | def get_user(username: str) -> Optional[UserInDB]:
    |                                ^^^^^^^^^^^^^^^^^^
219 |     """Récupérer un utilisateur par username"""
220 |     conn = get_auth_db()
    |
help: Convert to `X | None`

UP045 [*] Use `X | None` for type annotations
   --> ai-orchestrator/backend/auth.py:241:37
    |
241 | def get_user_by_id(user_id: int) -> Optional[User]:
    |                                     ^^^^^^^^^^^^^^
242 |     """Récupérer un utilisateur par son ID"""
243 |     conn = get_auth_db()
    |
help: Convert to `X | None`

UP045 [*] Use `X | None` for type annotations
   --> ai-orchestrator/backend/auth.py:263:35
    |
263 | def get_user_id(username: str) -> Optional[int]:
    |                                   ^^^^^^^^^^^^^
264 |     """Récupérer l'ID d'un utilisateur par son username"""
265 |     conn = get_auth_db()
    |
help: Convert to `X | None`

B904 Within an `except` clause, raise exceptions with `raise ... from err` or `raise ... from None` to distinguish them from errors in exception handling
   --> ai-orchestrator/backend/auth.py:293:9
    |
291 |       except sqlite3.IntegrityError:
292 |           conn.close()
293 | /         raise HTTPException(
294 | |             status_code=status.HTTP_400_BAD_REQUEST, detail="Username already exists"
295 | |         )
    | |_________^
296 |       finally:
297 |           conn.close()
    |

UP045 [*] Use `X | None` for type annotations
   --> ai-orchestrator/backend/auth.py:304:55
    |
304 | def update_user(username: str, update: UserUpdate) -> Optional[User]:
    |                                                       ^^^^^^^^^^^^^^
305 |     """Mettre à jour un utilisateur"""
306 |     conn = get_auth_db()
    |
help: Convert to `X | None`

S608 Possible SQL injection vector through string-based query construction
   --> ai-orchestrator/backend/auth.py:327:19
    |
325 |         updates.append("updated_at = CURRENT_TIMESTAMP")
326 |         values.append(username)
327 |         c.execute(f"""UPDATE users SET {", ".join(updates)} WHERE username = ?""", values)
    |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
328 |         conn.commit()
    |

UP045 [*] Use `X | None` for type annotations
   --> ai-orchestrator/backend/auth.py:334:56
    |
334 | def authenticate_user(username: str, password: str) -> Optional[UserInDB]:
    |                                                        ^^^^^^^^^^^^^^^^^^
335 |     """Authentifier un utilisateur"""
336 |     user = get_user(username)
    |
help: Convert to `X | None`

UP045 [*] Use `X | None` for type annotations
   --> ai-orchestrator/backend/auth.py:347:52
    |
347 | def create_access_token(data: dict, expires_delta: Optional[timedelta] = None) -> str:
    |                                                    ^^^^^^^^^^^^^^^^^^^
348 |     """Créer un token JWT d'accès"""
349 |     to_encode = data.copy()
    |
help: Convert to `X | None`

UP045 [*] Use `X | None` for type annotations
   --> ai-orchestrator/backend/auth.py:374:33
    |
374 | def verify_token(token: str) -> Optional[TokenData]:
    |                                 ^^^^^^^^^^^^^^^^^^^
375 |     """Vérifier et décoder un token JWT"""
376 |     try:
    |
help: Convert to `X | None`

UP006 [*] Use `list` instead of `List` for type annotation
   --> ai-orchestrator/backend/auth.py:379:17
    |
377 |         payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
378 |         username: str = payload.get("sub")
379 |         scopes: List[str] = payload.get("scopes", [])
    |                 ^^^^
380 |
381 |         if username is None:
    |
help: Replace with `list`

UP045 [*] Use `X | None` for type annotations
   --> ai-orchestrator/backend/auth.py:391:41
    |
391 | def verify_refresh_token(token: str) -> Optional[int]:
    |                                         ^^^^^^^^^^^^^
392 |     """Vérifier un refresh token et retourner l'user_id"""
393 |     token_hash = hash_token(token)
    |
help: Convert to `X | None`

UP006 [*] Use `list` instead of `List` for type annotation
   --> ai-orchestrator/backend/auth.py:425:38
    |
424 | def create_api_key(
425 |     name: str, user_id: int, scopes: List[str], expires_days: Optional[int] = None
    |                                      ^^^^
426 | ) -> str:
427 |     """Créer une nouvelle API key"""
    |
help: Replace with `list`

UP045 [*] Use `X | None` for type annotations
   --> ai-orchestrator/backend/auth.py:425:63
    |
424 | def create_api_key(
425 |     name: str, user_id: int, scopes: List[str], expires_days: Optional[int] = None
    |                                                               ^^^^^^^^^^^^^
426 | ) -> str:
427 |     """Créer une nouvelle API key"""
    |
help: Convert to `X | None`

UP045 [*] Use `X | None` for type annotations
   --> ai-orchestrator/backend/auth.py:449:33
    |
449 | def verify_api_key(key: str) -> Optional[Dict]:
    |                                 ^^^^^^^^^^^^^^
450 |     """Vérifier une API key"""
451 |     if not key or not key.startswith("ak_"):
    |
help: Convert to `X | None`

UP006 [*] Use `dict` instead of `Dict` for type annotation
   --> ai-orchestrator/backend/auth.py:449:42
    |
449 | def verify_api_key(key: str) -> Optional[Dict]:
    |                                          ^^^^
450 |     """Vérifier une API key"""
451 |     if not key or not key.startswith("ak_"):
    |
help: Replace with `dict`

UP045 [*] Use `X | None` for type annotations
   --> ai-orchestrator/backend/auth.py:528:12
    |
526 | async def get_current_user(
527 |     request: Request,
528 |     token: Optional[str] = Depends(oauth2_scheme),
    |            ^^^^^^^^^^^^^
529 |     api_key: Optional[str] = Depends(API_KEY_HEADER),
530 | ) -> Optional[User]:
    |
help: Convert to `X | None`

UP045 [*] Use `X | None` for type annotations
   --> ai-orchestrator/backend/auth.py:529:14
    |
527 |     request: Request,
528 |     token: Optional[str] = Depends(oauth2_scheme),
529 |     api_key: Optional[str] = Depends(API_KEY_HEADER),
    |              ^^^^^^^^^^^^^
530 | ) -> Optional[User]:
531 |     """
    |
help: Convert to `X | None`

UP045 [*] Use `X | None` for type annotations
   --> ai-orchestrator/backend/auth.py:530:6
    |
528 |     token: Optional[str] = Depends(oauth2_scheme),
529 |     api_key: Optional[str] = Depends(API_KEY_HEADER),
530 | ) -> Optional[User]:
    |      ^^^^^^^^^^^^^^
531 |     """
532 |     Obtenir l'utilisateur courant depuis le token JWT ou l'API key
    |
help: Convert to `X | None`

UP045 [*] Use `X | None` for type annotations
   --> ai-orchestrator/backend/auth.py:568:49
    |
568 | async def get_current_active_user(current_user: Optional[User] = Depends(get_current_user)) -> User:
    |                                                 ^^^^^^^^^^^^^^
569 |     """
570 |     Obtenir l'utilisateur courant actif (requis)
    |
help: Convert to `X | None`

B008 Do not perform function call `Depends` in argument defaults; instead, perform the call within the function, or read the default from a module-level singleton variable
   --> ai-orchestrator/backend/auth.py:568:66
    |
568 | async def get_current_active_user(current_user: Optional[User] = Depends(get_current_user)) -> User:
    |                                                                  ^^^^^^^^^^^^^^^^^^^^^^^^^
569 |     """
570 |     Obtenir l'utilisateur courant actif (requis)
    |

B008 Do not perform function call `Depends` in argument defaults; instead, perform the call within the function, or read the default from a module-level singleton variable
   --> ai-orchestrator/backend/auth.py:581:55
    |
581 | async def get_current_admin_user(current_user: User = Depends(get_current_active_user)) -> User:
    |                                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
582 |     """
583 |     Obtenir l'utilisateur courant admin
    |

B008 Do not perform function call `Depends` in argument defaults; instead, perform the call within the function, or read the default from a module-level singleton variable
   --> ai-orchestrator/backend/auth.py:597:50
    |
595 |     """
596 |
597 |     async def scope_checker(current_user: User = Depends(get_current_active_user)) -> User:
    |                                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
598 |         if scope not in current_user.scopes and "admin" not in current_user.scopes:
599 |             raise HTTPException(
    |

UP045 [*] Use `X | None` for type annotations
   --> ai-orchestrator/backend/auth.py:613:19
    |
612 | async def get_optional_user(
613 |     current_user: Optional[User] = Depends(get_current_user),
    |                   ^^^^^^^^^^^^^^
614 | ) -> Optional[User]:
615 |     """
    |
help: Convert to `X | None`

B008 Do not perform function call `Depends` in argument defaults; instead, perform the call within the function, or read the default from a module-level singleton variable
   --> ai-orchestrator/backend/auth.py:613:36
    |
612 | async def get_optional_user(
613 |     current_user: Optional[User] = Depends(get_current_user),
    |                                    ^^^^^^^^^^^^^^^^^^^^^^^^^
614 | ) -> Optional[User]:
615 |     """
    |

UP045 [*] Use `X | None` for type annotations
   --> ai-orchestrator/backend/auth.py:614:6
    |
612 | async def get_optional_user(
613 |     current_user: Optional[User] = Depends(get_current_user),
614 | ) -> Optional[User]:
    |      ^^^^^^^^^^^^^^
615 |     """
616 |     Obtenir l'utilisateur courant si l'auth est activée
    |
help: Convert to `X | None`

UP035 `typing.Dict` is deprecated, use `dict` instead
  --> ai-orchestrator/backend/auto_learn.py:9:1
   |
 7 | import re
 8 | from datetime import datetime
 9 | from typing import Dict, List, Optional
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
10 |
11 | import chromadb
   |

UP035 `typing.List` is deprecated, use `list` instead
  --> ai-orchestrator/backend/auto_learn.py:9:1
   |
 7 | import re
 8 | from datetime import datetime
 9 | from typing import Dict, List, Optional
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
10 |
11 | import chromadb
   |

UP006 [*] Use `list` instead of `List` for type annotation
  --> ai-orchestrator/backend/auto_learn.py:61:49
   |
61 | def extract_facts_from_message(message: str) -> List[Dict]:
   |                                                 ^^^^
62 |     """
63 |     Extraire automatiquement les faits d'un message utilisateur
   |
help: Replace with `list`

UP006 [*] Use `dict` instead of `Dict` for type annotation
  --> ai-orchestrator/backend/auto_learn.py:61:54
   |
61 | def extract_facts_from_message(message: str) -> List[Dict]:
   |                                                      ^^^^
62 |     """
63 |     Extraire automatiquement les faits d'un message utilisateur
   |
help: Replace with `dict`

UP006 [*] Use `list` instead of `List` for type annotation
  --> ai-orchestrator/backend/auto_learn.py:92:44
   |
92 | def extract_problem_solution(conversation: List[Dict]) -> Optional[Dict]:
   |                                            ^^^^
93 |     """
94 |     Analyser une conversation pour extraire un problème et sa solution
   |
help: Replace with `list`

UP006 [*] Use `dict` instead of `Dict` for type annotation
  --> ai-orchestrator/backend/auto_learn.py:92:49
   |
92 | def extract_problem_solution(conversation: List[Dict]) -> Optional[Dict]:
   |                                                 ^^^^
93 |     """
94 |     Analyser une conversation pour extraire un problème et sa solution
   |
help: Replace with `dict`

UP045 [*] Use `X | None` for type annotations
  --> ai-orchestrator/backend/auto_learn.py:92:59
   |
92 | def extract_problem_solution(conversation: List[Dict]) -> Optional[Dict]:
   |                                                           ^^^^^^^^^^^^^^
93 |     """
94 |     Analyser une conversation pour extraire un problème et sa solution
   |
help: Convert to `X | None`

UP006 [*] Use `dict` instead of `Dict` for type annotation
  --> ai-orchestrator/backend/auto_learn.py:92:68
   |
92 | def extract_problem_solution(conversation: List[Dict]) -> Optional[Dict]:
   |                                                                    ^^^^
93 |     """
94 |     Analyser une conversation pour extraire un problème et sa solution
   |
help: Replace with `dict`

UP006 [*] Use `list` instead of `List` for type annotation
   --> ai-orchestrator/backend/auto_learn.py:130:42
    |
130 | def summarize_conversation(conversation: List[Dict]) -> str:
    |                                          ^^^^
131 |     """
132 |     Créer un résumé de la conversation
    |
help: Replace with `list`

UP006 [*] Use `dict` instead of `Dict` for type annotation
   --> ai-orchestrator/backend/auto_learn.py:130:47
    |
130 | def summarize_conversation(conversation: List[Dict]) -> str:
    |                                               ^^^^
131 |     """
132 |     Créer un résumé de la conversation
    |
help: Replace with `dict`

UP006 [*] Use `list` instead of `List` for type annotation
   --> ai-orchestrator/backend/auto_learn.py:152:68
    |
152 | def auto_learn_from_message(message: str, conversation_id: str) -> List[str]:
    |                                                                    ^^^^
153 |     """
154 |     Fonction principale d'auto-apprentissage
    |
help: Replace with `list`

UP006 [*] Use `list` instead of `List` for type annotation
   --> ai-orchestrator/backend/auto_learn.py:196:45
    |
196 | def save_conversation_summary(conversation: List[Dict], conversation_id: str) -> bool:
    |                                             ^^^^
197 |     """
198 |     Sauvegarder le résumé d'une conversation terminée
    |
help: Replace with `list`

UP006 [*] Use `dict` instead of `Dict` for type annotation
   --> ai-orchestrator/backend/auto_learn.py:196:50
    |
196 | def save_conversation_summary(conversation: List[Dict], conversation_id: str) -> bool:
    |                                                  ^^^^
197 |     """
198 |     Sauvegarder le résumé d'une conversation terminée
    |
help: Replace with `dict`

UP006 [*] Use `list` instead of `List` for type annotation
   --> ai-orchestrator/backend/auto_learn.py:247:57
    |
247 | def get_relevant_context(query: str, limit: int = 5) -> List[str]:
    |                                                         ^^^^
248 |     """
249 |     Récupérer le contexte pertinent pour une nouvelle requête
    |
help: Replace with `list`

UP006 [*] Use `dict` instead of `Dict` for type annotation
   --> ai-orchestrator/backend/auto_learn.py:283:31
    |
283 | def get_user_preferences() -> Dict:
    |                               ^^^^
284 |     """
285 |     Récupérer les préférences utilisateur stockées
    |
help: Replace with `dict`

UP006 [*] Use `dict` instead of `Dict` for type annotation
   --> ai-orchestrator/backend/auto_learn.py:310:27
    |
310 | def get_memory_stats() -> Dict:
    |                           ^^^^
311 |     """
312 |     Obtenir les statistiques de la mémoire
    |
help: Replace with `dict`

UP035 `typing.List` is deprecated, use `list` instead
  --> ai-orchestrator/backend/config.py:9:1
   |
 7 | import os
 8 | from functools import lru_cache
 9 | from typing import List
   | ^^^^^^^^^^^^^^^^^^^^^^^
10 |
11 | from pydantic_settings import BaseSettings
   |

S104 Possible binding to all interfaces
  --> ai-orchestrator/backend/config.py:23:17
   |
22 |     # === SERVEUR ===
23 |     host: str = "0.0.0.0"
   |                 ^^^^^^^^^
24 |     port: int = 8001
   |

UP006 [*] Use `list` instead of `List` for type annotation
  --> ai-orchestrator/backend/config.py:65:19
   |
64 |     # CORS
65 |     cors_origins: List[str] = [
   |                   ^^^^
66 |         "https://ai.4lb.ca",
67 |         "https://4lb.ca",
   |
help: Replace with `list`

UP006 [*] Use `list` instead of `List` for type annotation
  --> ai-orchestrator/backend/config.py:72:25
   |
70 |     ]
71 |     cors_allow_credentials: bool = True
72 |     cors_allow_methods: List[str] = ["GET", "POST", "PUT", "DELETE", "OPTIONS"]
   |                         ^^^^
73 |     cors_allow_headers: List[str] = ["*"]
   |
help: Replace with `list`

UP006 [*] Use `list` instead of `List` for type annotation
  --> ai-orchestrator/backend/config.py:73:25
   |
71 |     cors_allow_credentials: bool = True
72 |     cors_allow_methods: List[str] = ["GET", "POST", "PUT", "DELETE", "OPTIONS"]
73 |     cors_allow_headers: List[str] = ["*"]
   |                         ^^^^
74 |
75 |     # Rate Limiting
   |
help: Replace with `list`

UP011 [*] Unnecessary parentheses to `functools.lru_cache`
  --> ai-orchestrator/backend/config.py:95:11
   |
95 | @lru_cache()
   |           ^^
96 | def get_settings() -> Settings:
97 |     """Obtenir les settings (cached)"""
   |
help: Remove unnecessary parentheses

UP035 `typing.Dict` is deprecated, use `dict` instead
  --> ai-orchestrator/backend/document_chunker.py:10:1
   |
 8 | import re
 9 | from dataclasses import dataclass
10 | from typing import Dict, List, Optional
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |

UP035 `typing.List` is deprecated, use `list` instead
  --> ai-orchestrator/backend/document_chunker.py:10:1
   |
 8 | import re
 9 | from dataclasses import dataclass
10 | from typing import Dict, List, Optional
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |

F401 [*] `typing.Optional` imported but unused
  --> ai-orchestrator/backend/document_chunker.py:10:32
   |
 8 | import re
 9 | from dataclasses import dataclass
10 | from typing import Dict, List, Optional
   |                                ^^^^^^^^
   |
help: Remove unused import: `typing.Optional`

UP006 [*] Use `dict` instead of `Dict` for type annotation
  --> ai-orchestrator/backend/document_chunker.py:21:15
   |
19 |     start_char: int
20 |     end_char: int
21 |     metadata: Dict
   |               ^^^^
   |
help: Replace with `dict`

UP006 [*] Use `list` instead of `List` for type annotation
  --> ai-orchestrator/backend/document_chunker.py:35:40
   |
35 | def split_into_sentences(text: str) -> List[str]:
   |                                        ^^^^
36 |     """Decouper texte en phrases"""
37 |     # Pattern pour fin de phrase (., !, ?, :) suivi d'espace ou fin
   |
help: Replace with `list`

UP006 [*] Use `list` instead of `List` for type annotation
  --> ai-orchestrator/backend/document_chunker.py:43:41
   |
43 | def split_into_paragraphs(text: str) -> List[str]:
   |                                         ^^^^
44 |     """Decouper texte en paragraphes"""
45 |     paragraphs = re.split(r"\n\s*\n", text)
   |
help: Replace with `list`

UP006 [*] Use `list` instead of `List` for type annotation
  --> ai-orchestrator/backend/document_chunker.py:54:6
   |
52 |     overlap: int = DEFAULT_OVERLAP,
53 |     respect_sentences: bool = True,
54 | ) -> List[Chunk]:
   |      ^^^^
55 |     """
56 |     Decouper un texte en chunks avec overlap
   |
help: Replace with `list`

UP006 [*] Use `list` instead of `List` for type annotation
   --> ai-orchestrator/backend/document_chunker.py:190:6
    |
188 |     chunk_size: int = DEFAULT_CHUNK_SIZE,
189 |     overlap: int = DEFAULT_OVERLAP,
190 | ) -> List[Dict]:
    |      ^^^^
191 |     """
192 |     Chunker le contenu d'un fichier avec metadata enrichies
    |
help: Replace with `list`

UP006 [*] Use `dict` instead of `Dict` for type annotation
   --> ai-orchestrator/backend/document_chunker.py:190:11
    |
188 |     chunk_size: int = DEFAULT_CHUNK_SIZE,
189 |     overlap: int = DEFAULT_OVERLAP,
190 | ) -> List[Dict]:
    |           ^^^^
191 |     """
192 |     Chunker le contenu d'un fichier avec metadata enrichies
    |
help: Replace with `dict`

UP006 [*] Use `list` instead of `List` for type annotation
   --> ai-orchestrator/backend/document_chunker.py:237:64
    |
237 | def chunk_code(content: str, chunk_size: int, overlap: int) -> List[Chunk]:
    |                                                                ^^^^
238 |     """Chunker du code en respectant les blocs (fonctions, classes)"""
239 |     # Pattern pour detecter les debuts de fonctions/classes Python
    |
help: Replace with `list`

B007 Loop control variable `i` not used within loop body
   --> ai-orchestrator/backend/document_chunker.py:248:9
    |
246 |     char_pos = 0
247 |
248 |     for i, line in enumerate(lines):
    |         ^
249 |         if re.match(block_pattern, line.strip()) and current_block:
250 |             # Nouveau bloc, sauvegarder l'ancien
    |
help: Rename unused `i` to `_i`

UP006 [*] Use `list` instead of `List` for type annotation
   --> ai-orchestrator/backend/document_chunker.py:329:68
    |
329 | def chunk_markdown(content: str, chunk_size: int, overlap: int) -> List[Chunk]:
    |                                                                    ^^^^
330 |     """Chunker du markdown en respectant les sections (headers)"""
331 |     # Pattern pour headers markdown
    |
help: Replace with `list`

E722 Do not use bare `except`
  --> ai-orchestrator/backend/dynamic_context.py:57:9
   |
55 |             status = "✅ Actif" if code == 0 else "❌ Inactif"
56 |             status_lines.append(f"- {svc}: {status}")
57 |         except:
   |         ^^^^^^
58 |             pass
   |

S110 `try`-`except`-`pass` detected, consider logging the exception
  --> ai-orchestrator/backend/dynamic_context.py:57:9
   |
55 |               status = "✅ Actif" if code == 0 else "❌ Inactif"
56 |               status_lines.append(f"- {svc}: {status}")
57 | /         except:
58 | |             pass
   | |________________^
59 |
60 |       if status_lines:
   |

I001 [*] Import block is un-sorted or un-formatted
  --> ai-orchestrator/backend/engine.py:9:1
   |
 7 |   """
 8 |
 9 | / import asyncio
10 | | import logging
11 | | import re
12 | | from typing import Optional
13 | |
14 | | import httpx
15 | | from fastapi import WebSocket
16 | |
17 | | from config import get_settings
   | |_______________________________^
18 |   # RAG Apogée v2.0
19 |   try:
   |
help: Organize imports

I001 [*] Import block is un-sorted or un-formatted
  --> ai-orchestrator/backend/engine.py:20:5
   |
18 | # RAG Apogée v2.0
19 | try:
20 |     from services.rag import inject_rag_context, get_search_service
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
21 |     RAG_AVAILABLE = True
22 | except ImportError:
   |
help: Organize imports

F401 `services.rag.get_search_service` imported but unused; consider using `importlib.util.find_spec` to test for availability
  --> ai-orchestrator/backend/engine.py:20:50
   |
18 | # RAG Apogée v2.0
19 | try:
20 |     from services.rag import inject_rag_context, get_search_service
   |                                                  ^^^^^^^^^^^^^^^^^^
21 |     RAG_AVAILABLE = True
22 | except ImportError:
   |
help: Remove unused import: `services.rag.get_search_service`

UP045 [*] Use `X | None` for type annotations
  --> ai-orchestrator/backend/engine.py:39:40
   |
39 | def extract_final_answer(text: str) -> Optional[str]:
   |                                        ^^^^^^^^^^^^^
40 |     """Extraire final_answer - ROBUSTE v5.5"""
   |
help: Convert to `X | None`

I001 [*] Import block is un-sorted or un-formatted
   --> ai-orchestrator/backend/engine.py:152:5
    |
150 |       """Boucle ReAct v5.5 - THINK -> PLAN -> ACTION -> OBSERVE"""
151 |
152 | /     from prompts import build_system_prompt, classify_query, get_urgency_message, get_factual_prompt
153 | |     from dynamic_context import get_dynamic_context
154 | |     from tools import get_tools_description
    | |___________________________________________^
155 |
156 |       # P1-2 FIX: Classification de la requête
    |
help: Organize imports

F401 [*] `prompts.get_factual_prompt` imported but unused
   --> ai-orchestrator/backend/engine.py:152:83
    |
150 |     """Boucle ReAct v5.5 - THINK -> PLAN -> ACTION -> OBSERVE"""
151 |
152 |     from prompts import build_system_prompt, classify_query, get_urgency_message, get_factual_prompt
    |                                                                                   ^^^^^^^^^^^^^^^^^^
153 |     from dynamic_context import get_dynamic_context
154 |     from tools import get_tools_description
    |
help: Remove unused import: `prompts.get_factual_prompt`

E501 Line too long (127 > 100)
   --> ai-orchestrator/backend/engine.py:198:101
    |
196 |             if rag_result.injected:
197 |                 messages[0]["content"] = enriched_prompt
198 |                 logger.info(f"RAG contexte injecté: {len(rag_result.sources)} sources, score={rag_result.relevance_score:.2f}")
    |                                                                                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^
199 |             else:
200 |                 logger.info("RAG: Pas de contexte pertinent trouvé")
    |

E501 Line too long (108 > 100)
   --> ai-orchestrator/backend/engine.py:207:101
    |
205 |                 "memory_recall", {"query": context_query, "limit": 5}, uploaded_files
206 |             )
207 |             if context_result and "Aucun souvenir" not in context_result and "Erreur" not in context_result:
    |                                                                                                     ^^^^^^^^
208 |                 context_injection = f"\n\n## CONTEXTE MEMORISE:\n{context_result}\n"
209 |                 messages[0]["content"] = system_prompt + context_injection
    |

E501 Line too long (101 > 100)
   --> ai-orchestrator/backend/engine.py:270:102
    |
268 | …                         {
269 | …                             "type": "thinking",
270 | …                             "message": "⚠️ Cloud saturé. Passage sur modèle local...",
    |                                                                                       ^
271 | …                         }
272 | …                     )
    |

E501 Line too long (112 > 100)
   --> ai-orchestrator/backend/engine.py:279:102
    |
277 | …                     # Si on est déjà en local ou autre, on attend
278 | …                     wait_time = 5 * (2**retry)
279 | …                     msg = f"⚠️ Serveur occupé. Attente {wait_time}s... (Essai {retry + 1}/{max_retries})"
    |                                                                                               ^^^^^^^^^^^^
280 | …                     logger.warning(msg)
281 | …                     if websocket:
    |

E501 Line too long (102 > 100)
   --> ai-orchestrator/backend/engine.py:293:101
    |
291 | …                     ):
292 | …                         logger.warning(
293 | …                             f"Erreur {r.status_code} sur {current_model}. Fallback sur local."
    |                                                                                               ^^
294 | …                         )
295 | …                         current_model = "qwen2.5-coder:32b-instruct-q4_K_M"
    |

E501 Line too long (117 > 100)
   --> ai-orchestrator/backend/engine.py:387:102
    |
385 |                 {
386 |                     "role": "user",
387 |                     "content": "⚠️ FORMAT INCORRECT. Tu dois utiliser ACTION: outil(param='valeur') ou final_answer.",
    |                                                                                                     ^^^^^^^^^^^^^^^^^
388 |                 }
389 |             )
    |

UP035 `typing.Dict` is deprecated, use `dict` instead
  --> ai-orchestrator/backend/file_indexer.py:21:1
   |
19 | from datetime import datetime
20 | from pathlib import Path
21 | from typing import Dict, List, Optional, Set
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
22 |
23 | import httpx
   |

UP035 `typing.List` is deprecated, use `list` instead
  --> ai-orchestrator/backend/file_indexer.py:21:1
   |
19 | from datetime import datetime
20 | from pathlib import Path
21 | from typing import Dict, List, Optional, Set
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
22 |
23 | import httpx
   |

UP035 `typing.Set` is deprecated, use `set` instead
  --> ai-orchestrator/backend/file_indexer.py:21:1
   |
19 | from datetime import datetime
20 | from pathlib import Path
21 | from typing import Dict, List, Optional, Set
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
22 |
23 | import httpx
   |

F401 [*] `typing.Set` imported but unused
  --> ai-orchestrator/backend/file_indexer.py:21:42
   |
19 | from datetime import datetime
20 | from pathlib import Path
21 | from typing import Dict, List, Optional, Set
   |                                          ^^^
22 |
23 | import httpx
   |
help: Remove unused import: `typing.Set`

UP006 [*] Use `dict` instead of `Dict` for type annotation
  --> ai-orchestrator/backend/file_indexer.py:96:17
   |
95 | # Cache des fichiers indexes (hash -> timestamp)
96 | _indexed_files: Dict[str, float] = {}
   |                 ^^^^
   |
help: Replace with `dict`

UP045 [*] Use `X | None` for type annotations
   --> ai-orchestrator/backend/file_indexer.py:111:33
    |
111 | def get_file_type(path: str) -> Optional[str]:
    |                                 ^^^^^^^^^^^^^
112 |     """Determiner le type de fichier"""
113 |     ext = Path(path).suffix.lower()
    |
help: Convert to `X | None`

S324 Probable use of insecure hash functions in `hashlib`: `md5`
   --> ai-orchestrator/backend/file_indexer.py:119:12
    |
117 | def get_file_hash(content: str) -> str:
118 |     """Calculer hash du contenu"""
119 |     return hashlib.md5(content.encode()).hexdigest()
    |            ^^^^^^^^^^^
    |

UP045 [*] Use `X | None` for type annotations
   --> ai-orchestrator/backend/file_indexer.py:122:39
    |
122 | async def get_embedding(text: str) -> Optional[List[float]]:
    |                                       ^^^^^^^^^^^^^^^^^^^^^
123 |     """Obtenir embedding via Ollama"""
124 |     try:
    |
help: Convert to `X | None`

UP006 [*] Use `list` instead of `List` for type annotation
   --> ai-orchestrator/backend/file_indexer.py:122:48
    |
122 | async def get_embedding(text: str) -> Optional[List[float]]:
    |                                                ^^^^
123 |     """Obtenir embedding via Ollama"""
124 |     try:
    |
help: Replace with `list`

UP015 [*] Unnecessary mode argument
   --> ai-orchestrator/backend/file_indexer.py:188:29
    |
186 |     # Lire contenu
187 |     try:
188 |         with open(filepath, "r", encoding="utf-8", errors="ignore") as f:
    |                             ^^^
189 |             content = f.read()
190 |     except Exception as e:
    |
help: Remove mode argument

E501 Line too long (103 > 100)
   --> ai-orchestrator/backend/file_indexer.py:253:100
    |
252 |         logger.info(
253 |             f"✅ Indexe: {relative_path} ({len(chunks)} chunks, {count_tokens_approx(content)} tokens)"
    |                                                                                                     ^^^
254 |         )
255 |         return True
    |

UP006 [*] Use `dict` instead of `Dict` for type annotation
   --> ai-orchestrator/backend/file_indexer.py:307:25
    |
305 |     def __init__(self, loop):
306 |         self.loop = loop
307 |         self._debounce: Dict[str, float] = {}
    |                         ^^^^
308 |         self._debounce_delay = 2.0  # secondes
    |
help: Replace with `dict`

E501 Line too long (233 > 100)
  --> ai-orchestrator/backend/index_knowledge.py:30:101
   |
28 | …
29 | …
30 | …D Ryzen 9 7900X 12 cores/24 threads, 64GB DDR5 RAM, NVIDIA RTX 5070 Ti 16GB VRAM, 2x NVMe (2TB Kingston systeme + 1TB ORICO modeles LLM)",
   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
31 | …
32 | …
   |

E501 Line too long (201 > 100)
  --> ai-orchestrator/backend/index_knowledge.py:35:101
   |
33 | …
34 | …
35 | …80.105.08. Utilise pour inference LLM via Ollama (15.4GB disponible). Commandes: nvidia-smi, nvtop pour monitoring.",
   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
36 | …
37 | …
   |

E501 Line too long (148 > 100)
  --> ai-orchestrator/backend/index_knowledge.py:40:101
   |
38 | …
39 | …
40 | …0.46, gateway UniFi Dream Machine Pro. VLANs segmentes. DNS local via Pi-hole optionnel.",
   |                                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
41 | …
42 | …
   |

E501 Line too long (193 > 100)
  --> ai-orchestrator/backend/index_knowledge.py:45:101
   |
43 | …
44 | …
45 | …(~300GB utilises, 18%). /dev/nvme0n1 (1TB ORICO) monte sur /mnt/ollama-models pour modeles LLM (~80GB modeles).",
   |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
46 | …
47 | …
   |

E501 Line too long (141 > 100)
  --> ai-orchestrator/backend/index_knowledge.py:50:101
   |
48 | …
49 | …
50 | … Swap 8GB. Commandes diagnostic: htop, free -h, df -h, lsblk, sensors (temperatures).",
   |                                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
51 | …
52 | …
   |

E501 Line too long (203 > 100)
  --> ai-orchestrator/backend/index_knowledge.py:56:101
   |
54 | …
55 | …
56 | …rse proxy), 4lbca_frontend, 4lbca_backend, 4lbca_llm, 4lbca_monitoring. Tous externes et interconnectes via Traefik.",
   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
57 | …
58 | …
   |

E501 Line too long (186 > 100)
  --> ai-orchestrator/backend/index_knowledge.py:61:101
   |
59 | …
60 | …
61 | …ied-stack/ avec 16+ services. Commandes: docker compose up -d, docker compose logs -f [service], docker ps.",
   |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
62 | …
63 | …
   |

E501 Line too long (221 > 100)
  --> ai-orchestrator/backend/index_knowledge.py:66:101
   |
64 | …
65 | …
66 | …s_data, grafana_data, prometheus_data, open_webui_data, ai_orchestrator_data, chromadb_data, code_server_data, crowdsec_data.",
   |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
67 | …
68 | …
   |

E501 Line too long (199 > 100)
  --> ai-orchestrator/backend/index_knowledge.py:72:101
   |
70 | …
71 | …
72 | …, 8080 (dashboard). Let's Encrypt automatique via HTTP challenge. Config dynamique dans /configs/traefik/dynamic/.",
   |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
73 | …
74 | …
   |

E501 Line too long (203 > 100)
  --> ai-orchestrator/backend/index_knowledge.py:77:101
   |
75 | …
76 | …
77 | …), grafana.4lb.ca (monitoring), traefik.4lb.ca (dashboard), jsr-solutions.ca (client JSR), jsr-dev.4lb.ca (dev JSR).",
   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
78 | …
79 | …
   |

E501 Line too long (212 > 100)
  --> ai-orchestrator/backend/index_knowledge.py:82:101
   |
80 | …
81 | …
82 | …o IP), crowdsec-bouncer (protection attaques). Plugins: crowdsec-bouncer-traefik-plugin v1.4.4, traefik-geoblock v1.1.1.",
   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
83 | …
84 | …
   |

E501 Line too long (159 > 100)
  --> ai-orchestrator/backend/index_knowledge.py:88:101
   |
86 | …
87 | …
88 | …principale: main, user: lalpha. Healthcheck: pg_isready. Backup: pg_dump. Reseau: unified-net.",
   |                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
89 | …
90 | …
   |

E501 Line too long (166 > 100)
  --> ai-orchestrator/backend/index_knowledge.py:93:101
   |
91 | …
92 | …
93 | …es). Container redis. Utilise pour cache, sessions, rate limiting. Commande test: redis-cli ping.",
   |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
94 | …
95 | …
   |

E501 Line too long (180 > 100)
   --> ai-orchestrator/backend/index_knowledge.py:98:101
    |
 96 | …
 97 | …
 98 | …essible via chromadb.4lb.ca. Collection principale: ai_orchestrator_memory_v2. API: /api/v2/collections.",
    |                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
 99 | …
100 | …
    |

E501 Line too long (190 > 100)
   --> ai-orchestrator/backend/index_knowledge.py:104:101
    |
102 | …
103 | …
104 | …34). Modeles stockes sur /mnt/ollama-models. Commandes: ollama list, ollama run [model], ollama pull [model].",
    |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
105 | …
106 | …
    |

E501 Line too long (223 > 100)
   --> ai-orchestrator/backend/index_knowledge.py:109:101
    |
107 | …
108 | …
109 | …l), deepseek-coder:33b (18GB, alternative), llama3.2-vision:11b-instruct-q8_0 (12GB, vision), qwen3-vl:32b (20GB, multimodal).",
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
110 | …
111 | …
    |

E501 Line too long (174 > 100)
   --> ai-orchestrator/backend/index_knowledge.py:114:101
    |
112 | …
113 | …
114 | …ud (code avance), kimi-k2:1t-cloud (Moonshot), gemini-3-pro-preview (Google). Limites rate possibles.",
    |                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
115 | …
116 | …
    |

E501 Line too long (179 > 100)
   --> ai-orchestrator/backend/index_knowledge.py:119:101
    |
117 | …
118 | …
119 | …multilingue, ACTIF), nomic-embed-text (274MB, 768 dim, legacy). mxbai recommande pour francais et code.",
    |                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
120 | …
121 | …
    |

E501 Line too long (237 > 100)
   --> ai-orchestrator/backend/index_knowledge.py:124:101
    |
122 | …
123 | …
124 | …inx. 55 outils (docker, fichiers, systeme, memoire, git, reseau). Interface: ai.4lb.ca. Code: /home/lalpha/projets/ai-tools/ai-orchestrator/",
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
125 | …
126 | …
    |

E501 Line too long (222 > 100)
   --> ai-orchestrator/backend/index_knowledge.py:129:101
    |
127 | …
128 | …
129 | …VE), prompts.py (system prompts + router), tools/ (9 modules outils), ChromaDB (memoire), auto_learn.py (apprentissage auto).",
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
130 | …
131 | …
    |

E501 Line too long (188 > 100)
   --> ai-orchestrator/backend/index_knowledge.py:134:101
    |
132 | …
133 | …
134 | …iner open-webui. Supporte RAG, documents, historique conversations. Alternative interface a AI Orchestrator.",
    |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
135 | …
136 | …
    |

E501 Line too long (181 > 100)
   --> ai-orchestrator/backend/index_knowledge.py:140:101
    |
138 | …
139 | …
140 | …ana (dashboards, grafana.4lb.ca), cAdvisor (conteneurs Docker), node-exporter (metriques systeme Linux).",
    |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
141 | …
142 | …
    |

E501 Line too long (163 > 100)
   --> ai-orchestrator/backend/index_knowledge.py:145:101
    |
143 | …
144 | …
145 | …s: Docker containers, Node metrics, Traefik stats. Datasources: Prometheus. Alerting configure.",
    |                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
146 | …
147 | …
    |

E501 Line too long (199 > 100)
   --> ai-orchestrator/backend/index_knowledge.py:150:101
    |
148 | …
149 | …
150 | … whitelist-good-actors, iptables, linux. Analyse logs Traefik. Commande: cscli decisions list, cscli alerts list.",
    |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
151 | …
152 | …
    |

E501 Line too long (177 > 100)
   --> ai-orchestrator/backend/index_knowledge.py:155:101
    |
153 | …
154 | …
155 | …STS), geoblock pays risques, CrowdSec IDS/IPS, secrets dans .env (jamais git), Docker networks isoles.",
    |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
156 | …
157 | …
    |

E501 Line too long (213 > 100)
   --> ai-orchestrator/backend/index_knowledge.py:161:101
    |
159 | …
160 | …
161 | …, clients/ (JSR, toilettage), infrastructure/ (unified-stack, configs), web-apps/ (sites perso), developpement/ (tests).",
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
162 | …
163 | …
    |

E501 Line too long (192 > 100)
   --> ai-orchestrator/backend/index_knowledge.py:166:101
    |
164 | …
165 | …
166 | …/. Backend Python FastAPI, Frontend HTML/JS. Docker Compose avec backend + frontend nginx. Git: github.com/...",
    |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
167 | …
168 | …
    |

E501 Line too long (210 > 100)
   --> ai-orchestrator/backend/index_knowledge.py:171:101
    |
169 | …
170 | …
171 | …ec. Site jsr-solutions.ca. Code: /home/lalpha/projets/clients/jsr/JSR-solutions/. Design vert moderne, Loi 25 conforme.",
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
172 | …
173 | …
    |

E501 Line too long (196 > 100)
   --> ai-orchestrator/backend/index_knowledge.py:176:101
    |
174 | …
175 | …
176 | … /home/lalpha/projets/clients/toilettage/versions/ (v1-backend-separe, v2-react-moderne, v3-monitoring-complet).",
    |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
177 | …
178 | …
    |

E501 Line too long (199 > 100)
   --> ai-orchestrator/backend/index_knowledge.py:181:101
    |
179 | …
180 | …
181 | …ets/infrastructure/unified-stack/. Docker Compose orchestrant tous les services (Traefik, DBs, monitoring, apps).",
    |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
182 | …
183 | …
    |

E501 Line too long (191 > 100)
   --> ai-orchestrator/backend/index_knowledge.py:187:101
    |
185 | …
186 | …
187 | …m/. Backups quotidiens automatiques via cron. Cibles: ai-orchestrator, postgres, configs. Logs dans cron.log.",
    |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
188 | …
189 | …
    |

E501 Line too long (179 > 100)
   --> ai-orchestrator/backend/index_knowledge.py:192:101
    |
190 | …
191 | …
192 | …ols/self-improvement/. Rapports automatiques analyse performance. Historique dans reports/history.json.",
    |                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
193 | …
194 | …
    |

E501 Line too long (135 > 100)
   --> ai-orchestrator/backend/index_knowledge.py:197:101
    |
195 | …
196 | …
197 | …le. Container code-server. Acces via Traefik. Utile pour edition code a distance.",
    |                                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
198 | …
199 | …
    |

E501 Line too long (189 > 100)
   --> ai-orchestrator/backend/index_knowledge.py:203:101
    |
201 | …
202 | …
203 | …iner], docker compose up -d, docker compose build [service], docker exec -it [container] bash, docker stats.",
    |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
204 | …
205 | …
    |

E501 Line too long (212 > 100)
   --> ai-orchestrator/backend/index_knowledge.py:208:101
    |
206 | …
207 | …
208 | …lhost:8001/health, curl localhost:8001/api/stats. Rebuild: docker compose build backend && docker compose up -d backend.",
    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
209 | …
210 | …
    |

E501 Line too long (194 > 100)
   --> ai-orchestrator/backend/index_knowledge.py:213:101
    |
211 | …
212 | …
213 | …er:32b (chat), ollama pull mxbai-embed-large (telecharger), curl http://10.10.10.46:11434/api/tags (API liste).",
    |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
214 | …
215 | …
    |

E501 Line too long (170 > 100)
   --> ai-orchestrator/backend/index_knowledge.py:219:101
    |
217 | …
218 | …
219 | …cations. Reponses techniques concises avec commandes exactes. Pas d'explications basiques inutiles.",
    |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
220 | …
221 | …
    |

E501 Line too long (187 > 100)
   --> ai-orchestrator/backend/index_knowledge.py:224:101
    |
222 | …
223 | …
224 | … Docker, Linux, Python, JavaScript, TypeScript, reseaux, securite. Prefere solutions directes et efficaces.",
    |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
225 | …
226 | …
    |

E501 Line too long (187 > 100)
   --> ai-orchestrator/backend/index_knowledge.py:229:101
    |
227 | …
228 | …
229 | …cker pour isolation, Git pour versionning, CI/CD, monitoring proactif, documentation minimale mais precise.",
    |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
230 | …
231 | …
    |

E501 Line too long (155 > 100)
   --> ai-orchestrator/backend/index_knowledge.py:234:101
    |
232 | …
233 | …
234 | …r), terminal ZSH, Git, Docker Compose, Python 3.11+, Node.js, Claude Code pour dev assiste.",
    |                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
235 | …
236 | …
    |

UP035 `typing.List` is deprecated, use `list` instead
  --> ai-orchestrator/backend/main.py:18:1
   |
16 | from datetime import datetime
17 | from pathlib import Path
18 | from typing import List, Optional
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
19 |
20 | import chromadb
   |

F401 `security.CommandNotAllowedError` imported but unused; consider using `importlib.util.find_spec` to test for availability
  --> ai-orchestrator/backend/main.py:50:9
   |
48 | try:
49 |     from security import (
50 |         CommandNotAllowedError,
   |         ^^^^^^^^^^^^^^^^^^^^^^
51 |         PathNotAllowedError,
52 |         audit_log,
   |
help: Remove unused import

F401 `security.PathNotAllowedError` imported but unused; consider using `importlib.util.find_spec` to test for availability
  --> ai-orchestrator/backend/main.py:51:9
   |
49 |     from security import (
50 |         CommandNotAllowedError,
51 |         PathNotAllowedError,
   |         ^^^^^^^^^^^^^^^^^^^
52 |         audit_log,
53 |         get_security_config,
   |
help: Remove unused import

F401 `security.is_path_allowed` imported but unused; consider using `importlib.util.find_spec` to test for availability
  --> ai-orchestrator/backend/main.py:54:9
   |
52 |         audit_log,
53 |         get_security_config,
54 |         is_path_allowed,
   |         ^^^^^^^^^^^^^^^
55 |         validate_command,
56 |         validate_path,
   |
help: Remove unused import

F401 `security.validate_path` imported but unused; consider using `importlib.util.find_spec` to test for availability
  --> ai-orchestrator/backend/main.py:56:9
   |
54 |         is_path_allowed,
55 |         validate_command,
56 |         validate_path,
   |         ^^^^^^^^^^^^^
57 |     )
   |
help: Remove unused import

F401 `auth.APIKey` imported but unused; consider using `importlib.util.find_spec` to test for availability
  --> ai-orchestrator/backend/main.py:67:9
   |
65 |     from auth import (
66 |         AUTH_ENABLED,
67 |         APIKey,
   |         ^^^^^^
68 |         Token,
69 |         User,
   |
help: Remove unused import

F401 `auth.User` imported but unused; consider using `importlib.util.find_spec` to test for availability
  --> ai-orchestrator/backend/main.py:69:9
   |
67 |         APIKey,
68 |         Token,
69 |         User,
   |         ^^^^
70 |         UserCreate,
71 |         UserUpdate,
   |
help: Remove unused import

F401 `auth.UserUpdate` imported but unused; consider using `importlib.util.find_spec` to test for availability
  --> ai-orchestrator/backend/main.py:71:9
   |
69 |         User,
70 |         UserCreate,
71 |         UserUpdate,
   |         ^^^^^^^^^^
72 |         authenticate_user,
73 |         check_login_rate_limit,
   |
help: Remove unused import

F401 `auth.get_current_user` imported but unused; consider using `importlib.util.find_spec` to test for availability
  --> ai-orchestrator/backend/main.py:80:9
   |
78 |         get_current_active_user,
79 |         get_current_admin_user,
80 |         get_current_user,
   |         ^^^^^^^^^^^^^^^^
81 |         get_optional_user,
82 |         get_user,
   |
help: Remove unused import

F401 `auth.get_user` imported but unused; consider using `importlib.util.find_spec` to test for availability
  --> ai-orchestrator/backend/main.py:82:9
   |
80 |         get_current_user,
81 |         get_optional_user,
82 |         get_user,
   |         ^^^^^^^^
83 |         get_user_by_id,
84 |         get_user_id,
   |
help: Remove unused import

F401 `auth.require_scope` imported but unused; consider using `importlib.util.find_spec` to test for availability
  --> ai-orchestrator/backend/main.py:87:9
   |
85 |         init_auth_db,
86 |         record_login_attempt,
87 |         require_scope,
   |         ^^^^^^^^^^^^^
88 |         revoke_refresh_token,
89 |         update_user,
   |
help: Remove unused import

F401 `auth.update_user` imported but unused; consider using `importlib.util.find_spec` to test for availability
  --> ai-orchestrator/backend/main.py:89:9
   |
87 |         require_scope,
88 |         revoke_refresh_token,
89 |         update_user,
   |         ^^^^^^^^^^^
90 |         verify_refresh_token,
91 |         verify_token,
   |
help: Remove unused import

F401 `rate_limiter.rate_limiter` imported but unused; consider using `importlib.util.find_spec` to test for availability
   --> ai-orchestrator/backend/main.py:98:87
    |
 97 | try:
 98 |     from rate_limiter import RateLimitMiddleware, cleanup_task, get_rate_limit_stats, rate_limiter
    |                                                                                       ^^^^^^^^^^^^
 99 |
100 |     RATE_LIMIT_ENABLED = True
    |
help: Remove unused import: `rate_limiter.rate_limiter`

F401 `config.MODELS` imported but unused; consider using `importlib.util.find_spec` to test for availability
   --> ai-orchestrator/backend/main.py:106:34
    |
105 | try:
106 |     from config import MODELS as CONFIG_MODELS
    |                                  ^^^^^^^^^^^^^
107 |     from config import get_cors_config, get_settings
    |
help: Remove unused import: `config.MODELS`

F401 `config.get_settings` imported but unused; consider using `importlib.util.find_spec` to test for availability
   --> ai-orchestrator/backend/main.py:107:41
    |
105 | try:
106 |     from config import MODELS as CONFIG_MODELS
107 |     from config import get_cors_config, get_settings
    |                                         ^^^^^^^^^^^^
108 |
109 |     CONFIG_ENABLED = True
    |
help: Remove unused import: `config.get_settings`

F401 `prompts.build_system_prompt` imported but unused; consider using `importlib.util.find_spec` to test for availability
   --> ai-orchestrator/backend/main.py:115:25
    |
114 | try:
115 |     from prompts import build_system_prompt, get_initial_memory_prompt, get_urgency_message
    |                         ^^^^^^^^^^^^^^^^^^^
116 |
117 |     PROMPTS_ENABLED = True
    |
help: Remove unused import

F401 `prompts.get_initial_memory_prompt` imported but unused; consider using `importlib.util.find_spec` to test for availability
   --> ai-orchestrator/backend/main.py:115:46
    |
114 | try:
115 |     from prompts import build_system_prompt, get_initial_memory_prompt, get_urgency_message
    |                                              ^^^^^^^^^^^^^^^^^^^^^^^^^
116 |
117 |     PROMPTS_ENABLED = True
    |
help: Remove unused import

F401 `prompts.get_urgency_message` imported but unused; consider using `importlib.util.find_spec` to test for availability
   --> ai-orchestrator/backend/main.py:115:73
    |
114 | try:
115 |     from prompts import build_system_prompt, get_initial_memory_prompt, get_urgency_message
    |                                                                         ^^^^^^^^^^^^^^^^^^^
116 |
117 |     PROMPTS_ENABLED = True
    |
help: Remove unused import

F401 `tools.get_tools_description` imported but unused; consider using `importlib.util.find_spec` to test for availability
   --> ai-orchestrator/backend/main.py:124:42
    |
122 | # ===== NOUVEAUX MODULES v4.0 =====
123 | try:
124 |     from tools import TOOLS_DEFINITIONS, get_tools_description
    |                                          ^^^^^^^^^^^^^^^^^^^^^
125 |     from tools import execute_tool as tools_execute_tool
126 |     from utils.async_subprocess import run_command_async, run_multiple_commands
    |
help: Remove unused import: `tools.get_tools_description`

F401 `utils.async_subprocess.run_command_async` imported but unused; consider using `importlib.util.find_spec` to test for availability
   --> ai-orchestrator/backend/main.py:126:40
    |
124 |     from tools import TOOLS_DEFINITIONS, get_tools_description
125 |     from tools import execute_tool as tools_execute_tool
126 |     from utils.async_subprocess import run_command_async, run_multiple_commands
    |                                        ^^^^^^^^^^^^^^^^^
127 |
128 |     TOOLS_MODULE_ENABLED = True
    |
help: Remove unused import

F401 `utils.async_subprocess.run_multiple_commands` imported but unused; consider using `importlib.util.find_spec` to test for availability
   --> ai-orchestrator/backend/main.py:126:59
    |
124 |     from tools import TOOLS_DEFINITIONS, get_tools_description
125 |     from tools import execute_tool as tools_execute_tool
126 |     from utils.async_subprocess import run_command_async, run_multiple_commands
    |                                                           ^^^^^^^^^^^^^^^^^^^^^
127 |
128 |     TOOLS_MODULE_ENABLED = True
    |
help: Remove unused import

F401 `dynamic_context.get_dynamic_context` imported but unused; consider using `importlib.util.find_spec` to test for availability
   --> ai-orchestrator/backend/main.py:135:33
    |
134 | try:
135 |     from dynamic_context import get_dynamic_context
    |                                 ^^^^^^^^^^^^^^^^^^^
136 |
137 |     DYNAMIC_CONTEXT_ENABLED = True
    |
help: Remove unused import: `dynamic_context.get_dynamic_context`

F401 `auto_learn.get_memory_stats` imported but unused; consider using `importlib.util.find_spec` to test for availability
   --> ai-orchestrator/backend/main.py:176:9
    |
174 |     from auto_learn import (
175 |         auto_learn_from_message,
176 |         get_memory_stats,
    |         ^^^^^^^^^^^^^^^^
177 |         get_relevant_context,
178 |         get_user_preferences,
    |
help: Remove unused import

F401 `auto_learn.get_user_preferences` imported but unused; consider using `importlib.util.find_spec` to test for availability
   --> ai-orchestrator/backend/main.py:178:9
    |
176 |         get_memory_stats,
177 |         get_relevant_context,
178 |         get_user_preferences,
    |         ^^^^^^^^^^^^^^^^^^^^
179 |         save_conversation_summary,
180 |     )
    |
help: Remove unused import

E501 Line too long (133 > 100)
   --> ai-orchestrator/backend/main.py:244:101
    |
242 |         "category": "code",
243 |         "local": True,
244 |         "keywords": ["code", "script", "python", "bash", "debug", "fonction", "variable", "api", "docker", "git", "npm", "programm"],
    |                                                                                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
245 |     },
246 |     "deepseek-coder": {
    |

E501 Line too long (108 > 100)
   --> ai-orchestrator/backend/main.py:261:101
    |
259 |         "category": "vision",
260 |         "local": True,
261 |         "keywords": ["image", "photo", "screenshot", "capture", "voir", "regarde", "analyse visuel", "ocr"],
    |                                                                                                     ^^^^^^^^
262 |     },
263 |     "qwen-vision": {
    |

UP015 [*] Unnecessary mode argument
   --> ai-orchestrator/backend/main.py:513:33
    |
511 |     else:
512 |         try:
513 |             with open(filepath, "r", encoding="utf-8") as f:
    |                                 ^^^
514 |                 content = f.read()
515 |             return content, "text"
    |
help: Remove mode argument

E722 Do not use bare `except`
   --> ai-orchestrator/backend/main.py:516:9
    |
514 |                 content = f.read()
515 |             return content, "text"
516 |         except:
    |         ^^^^^^
517 |             with open(filepath, "rb") as f:
518 |                 content = f.read().hex()
    |

E501 Line too long (109 > 100)
   --> ai-orchestrator/backend/main.py:544:100
    |
542 |     if not isinstance(conversation_id, str):
543 |         logger.error(
544 |             f"❌ add_message: conversation_id invalide (type={type(conversation_id)}, val={conversation_id})"
    |                                                                                                     ^^^^^^^^^
545 |         )
546 |         raise ValueError(f"conversation_id doit être une string, pas {type(conversation_id)}")
    |

E501 Line too long (121 > 100)
   --> ai-orchestrator/backend/main.py:598:101
    |
596 |     c.execute(
597 |         """SELECT c.*,
598 |                  (SELECT content FROM messages WHERE conversation_id = c.id ORDER BY created_at LIMIT 1) as first_message
    |                                                                                                     ^^^^^^^^^^^^^^^^^^^^^
599 |                  FROM conversations c
600 |                  ORDER BY updated_at DESC LIMIT ?""",
    |

E501 Line too long (106 > 100)
   --> ai-orchestrator/backend/main.py:668:100
    |
667 |     if not TOOLS_MODULE_ENABLED:
668 |         return "❌ ERREUR CRITIQUE: Le module tools v4.0 n'est pas chargé. Impossible d'exécuter l'outil."
    |                                                                                                     ^^^^^^
669 |
670 |     try:
    |

E402 Module level import not at top of file
   --> ai-orchestrator/backend/main.py:693:1
    |
692 | # ===== MOTEUR REACT =====
693 | from engine import react_loop
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
694 |
695 | # ===== APPLICATION FASTAPI =====
    |

UP045 [*] Use `X | None` for type annotations
   --> ai-orchestrator/backend/main.py:754:22
    |
752 |     message: str
753 |     model: str = "auto"
754 |     conversation_id: Optional[str] = None
    |                      ^^^^^^^^^^^^^
755 |     file_ids: Optional[List[str]] = None
    |
help: Convert to `X | None`

UP045 [*] Use `X | None` for type annotations
   --> ai-orchestrator/backend/main.py:755:15
    |
753 |     model: str = "auto"
754 |     conversation_id: Optional[str] = None
755 |     file_ids: Optional[List[str]] = None
    |               ^^^^^^^^^^^^^^^^^^^
    |
help: Convert to `X | None`

UP006 [*] Use `list` instead of `List` for type annotation
   --> ai-orchestrator/backend/main.py:755:24
    |
753 |     model: str = "auto"
754 |     conversation_id: Optional[str] = None
755 |     file_ids: Optional[List[str]] = None
    |                        ^^^^
    |
help: Replace with `list`

B008 Do not perform function call `Depends` in argument defaults; instead, perform the call within the function, or read the default from a module-level singleton variable
   --> ai-orchestrator/backend/main.py:788:74
    |
787 | @app.post("/api/auth/login", response_model=Token if AUTH_ENABLED else None)
788 | async def login(request: Request, form_data: OAuth2PasswordRequestForm = Depends()):
    |                                                                          ^^^^^^^^^
789 |     """Authentification et obtention d'un token JWT"""
790 |     if not AUTH_ENABLED:
    |

S106 Possible hardcoded password assigned to argument: "token_type"
   --> ai-orchestrator/backend/main.py:823:65
    |
822 |     return Token(
823 |         access_token=access_token, refresh_token=refresh_token, token_type="bearer", expires_in=3600
    |                                                                 ^^^^^^^^^^^^^^^^^^^
824 |     )
    |

B008 Do not perform function call `Depends` in argument defaults; instead, perform the call within the function, or read the default from a module-level singleton variable
   --> ai-orchestrator/backend/main.py:858:31
    |
857 | @app.get("/api/auth/me")
858 | async def get_me(current_user=Depends(get_current_active_user) if AUTH_ENABLED else None):
    |                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
859 |     """Obtenir les informations de l'utilisateur courant"""
860 |     if not AUTH_ENABLED:
    |

B008 Do not perform function call `Depends` in argument defaults; instead, perform the call within the function, or read the default from a module-level singleton variable
   --> ai-orchestrator/backend/main.py:867:41
    |
865 | @app.post("/api/auth/users")
866 | async def create_new_user(
867 |     user_data: UserCreate, current_user=Depends(get_current_admin_user) if AUTH_ENABLED else None
    |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
868 | ):
869 |     """Créer un nouvel utilisateur (admin requis)"""
    |

UP006 [*] Use `list` instead of `List` for type annotation
   --> ai-orchestrator/backend/main.py:878:13
    |
876 | async def create_new_api_key(
877 |     name: str,
878 |     scopes: List[str],
    |             ^^^^
879 |     expires_days: Optional[int] = None,
880 |     current_user=Depends(get_current_admin_user) if AUTH_ENABLED else None,
    |
help: Replace with `list`

UP045 [*] Use `X | None` for type annotations
   --> ai-orchestrator/backend/main.py:879:19
    |
877 |     name: str,
878 |     scopes: List[str],
879 |     expires_days: Optional[int] = None,
    |                   ^^^^^^^^^^^^^
880 |     current_user=Depends(get_current_admin_user) if AUTH_ENABLED else None,
881 | ):
    |
help: Convert to `X | None`

B008 Do not perform function call `Depends` in argument defaults; instead, perform the call within the function, or read the default from a module-level singleton variable
   --> ai-orchestrator/backend/main.py:880:18
    |
878 |     scopes: List[str],
879 |     expires_days: Optional[int] = None,
880 |     current_user=Depends(get_current_admin_user) if AUTH_ENABLED else None,
    |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
881 | ):
882 |     """Créer une nouvelle API key (admin requis)"""
    |

B008 Do not perform function call `Depends` in argument defaults; instead, perform the call within the function, or read the default from a module-level singleton variable
   --> ai-orchestrator/backend/main.py:892:18
    |
890 | @app.get("/api/security/config")
891 | async def get_security_config_endpoint(
892 |     current_user=Depends(get_current_admin_user) if AUTH_ENABLED else None,
    |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
893 | ):
894 |     """Obtenir la configuration de sécurité (admin requis)"""
    |

B008 Do not perform function call `Depends` in argument defaults; instead, perform the call within the function, or read the default from a module-level singleton variable
   --> ai-orchestrator/backend/main.py:902:18
    |
900 | @app.get("/api/security/rate-limit-stats")
901 | async def get_rate_limit_stats_endpoint(
902 |     current_user=Depends(get_current_admin_user) if AUTH_ENABLED else None,
    |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
903 | ):
904 |     """Obtenir les statistiques de rate limiting (admin requis)"""
    |

E501 Line too long (114 > 100)
   --> ai-orchestrator/backend/main.py:934:101
    |
932 |     return {
933 |         "models": [
934 |             {"id": k, "name": v["name"], "description": v["description"], "category": v.get("category", "other")} 
    |                                                                                                     ^^^^^^^^^^^^^^
935 |             for k, v in MODELS.items() if v.get("chat", True) is not False
936 |         ],
    |

B008 Do not perform function call `Depends` in argument defaults; instead, perform the call within the function, or read the default from a module-level singleton variable
   --> ai-orchestrator/backend/main.py:966:18
    |
964 | @app.post("/api/tools/reload")
965 | async def reload_tools_endpoint(
966 |     current_user=Depends(get_current_admin_user) if AUTH_ENABLED else None,
    |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
967 | ):
968 |     """Recharger les outils à chaud (admin requis) - pour l'auto-amélioration"""
    |

S607 Starting a process with a partial executable path
    --> ai-orchestrator/backend/main.py:1001:13
     |
 999 |         # CPU usage
1000 |         cpu_result = subprocess.run(
1001 |             ["sh", "-c", "top -bn1 | grep 'Cpu(s)' | awk '{print $2}'"],
     |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
1002 |             capture_output=True,
1003 |             text=True,
     |

S607 Starting a process with a partial executable path
    --> ai-orchestrator/backend/main.py:1008:39
     |
1006 |         stats["cpu"]["percent"] = round(float(cpu_result.stdout.strip() or 0), 1)
1007 |
1008 |         cores_result = subprocess.run(["nproc"], capture_output=True, text=True, timeout=5)
     |                                       ^^^^^^^^^
1009 |         stats["cpu"]["cores"] = int(cores_result.stdout.strip() or 0)
     |

S607 Starting a process with a partial executable path
    --> ai-orchestrator/backend/main.py:1013:13
     |
1011 |         # Memory
1012 |         mem_result = subprocess.run(
1013 |             ["sh", "-c", "free -b | awk '/^Mem:/ {print $2, $3}'"],
     |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
1014 |             capture_output=True,
1015 |             text=True,
     |

S108 Probable insecure usage of temporary file or directory: "/tmp/gpu-stats.txt"
    --> ai-orchestrator/backend/main.py:1028:23
     |
1026 |         # GPU (read from host file)
1027 |         try:
1028 |             with open("/tmp/gpu-stats.txt", "r") as f:
     |                       ^^^^^^^^^^^^^^^^^^^^
1029 |                 gpu_data = f.read().strip()
1030 |             if gpu_data:
     |

UP015 [*] Unnecessary mode argument
    --> ai-orchestrator/backend/main.py:1028:45
     |
1026 |         # GPU (read from host file)
1027 |         try:
1028 |             with open("/tmp/gpu-stats.txt", "r") as f:
     |                                             ^^^
1029 |                 gpu_data = f.read().strip()
1030 |             if gpu_data:
     |
help: Remove mode argument

S607 Starting a process with a partial executable path
    --> ai-orchestrator/backend/main.py:1042:13
     |
1040 |         # Docker
1041 |         docker_result = subprocess.run(
1042 |             ["sh", "-c", "docker ps -q 2>/dev/null | wc -l"],
     |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
1043 |             capture_output=True,
1044 |             text=True,
     |

S607 Starting a process with a partial executable path
    --> ai-orchestrator/backend/main.py:1050:13
     |
1049 |         docker_all = subprocess.run(
1050 |             ["sh", "-c", "docker ps -aq 2>/dev/null | wc -l"],
     |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
1051 |             capture_output=True,
1052 |             text=True,
     |

B008 Do not perform function call `File` in argument defaults; instead, perform the call within the function, or read the default from a module-level singleton variable
    --> ai-orchestrator/backend/main.py:1064:42
     |
1063 | @app.post("/api/upload")
1064 | async def upload_file(file: UploadFile = File(...), conversation_id: Optional[str] = Form(None)):
     |                                          ^^^^^^^^^
1065 |     """Upload un fichier"""
1066 |     try:
     |

UP045 [*] Use `X | None` for type annotations
    --> ai-orchestrator/backend/main.py:1064:70
     |
1063 | @app.post("/api/upload")
1064 | async def upload_file(file: UploadFile = File(...), conversation_id: Optional[str] = Form(None)):
     |                                                                      ^^^^^^^^^^^^^
1065 |     """Upload un fichier"""
1066 |     try:
     |
help: Convert to `X | None`

B904 Within an `except` clause, raise exceptions with `raise ... from err` or `raise ... from None` to distinguish them from errors in exception handling
    --> ai-orchestrator/backend/main.py:1070:9
     |
1068 |         return {"success": True, "file": result}
1069 |     except Exception as e:
1070 |         raise HTTPException(status_code=500, detail=str(e))
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
     |

B008 Do not perform function call `Depends` in argument defaults; instead, perform the call within the function, or read the default from a module-level singleton variable
    --> ai-orchestrator/backend/main.py:1075:40
     |
1073 | @app.post("/api/chat")
1074 | async def chat(
1075 |     request: ChatRequest, current_user=Depends(get_current_active_user) if AUTH_ENABLED else None
     |                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
1076 | ):
1077 |     """Endpoint chat synchrone"""
     |

E501 Line too long (109 > 100)
    --> ai-orchestrator/backend/main.py:1204:100
     |
1202 | …                     {
1203 | …                         "type": "activity",
1204 | …                         "action": f"🧠 Auto-apprentissage: {len(learned_facts)} fait(s) mémorisé(s)",
     |                                                                                               ^^^^^^^^^
1205 | …                         "details": ", ".join(learned_facts),
1206 | …                     }
     |

S607 Starting a process with a partial executable path
    --> ai-orchestrator/backend/main.py:1299:13
     |
1297 |     try:
1298 |         result = subprocess.run(
1299 |             ["docker", "ps", "-a", "--format", "{{json .}}"],
     |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
1300 |             capture_output=True,
1301 |             text=True,
     |

E722 Do not use bare `except`
    --> ai-orchestrator/backend/main.py:1317:17
     |
1315 |                         }
1316 |                     )
1317 |                 except:
     |                 ^^^^^^
1318 |                     pass
1319 |         return containers
     |

S110 `try`-`except`-`pass` detected, consider logging the exception
    --> ai-orchestrator/backend/main.py:1317:17
     |
1315 |                           }
1316 |                       )
1317 | /                 except:
1318 | |                     pass
     | |________________________^
1319 |           return containers
1320 |       except Exception as e:
     |

B008 Do not perform function call `Depends` in argument defaults; instead, perform the call within the function, or read the default from a module-level singleton variable
    --> ai-orchestrator/backend/main.py:1332:18
     |
1330 |     lines: int = 100,
1331 |     level: str = None,
1332 |     current_user=Depends(get_current_admin_user) if AUTH_ENABLED else None,
     |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
1333 | ):
1334 |     """Voir les dernières lignes des logs serveur (admin requis)"""
     |

UP015 [*] Unnecessary mode argument
    --> ai-orchestrator/backend/main.py:1336:33
     |
1334 |     """Voir les dernières lignes des logs serveur (admin requis)"""
1335 |     try:
1336 |         with open("server.log", "r") as f:
     |                                 ^^^
1337 |             all_lines = f.readlines()
     |
help: Remove mode argument

E741 Ambiguous variable name: `l`
    --> ai-orchestrator/backend/main.py:1342:32
     |
1340 |         if level:
1341 |             level = level.upper()
1342 |             all_lines = [l for l in all_lines if f"[{level}]" in l]
     |                                ^
1343 |
1344 |         # Retourner les N dernières lignes
     |

E741 Ambiguous variable name: `l`
    --> ai-orchestrator/backend/main.py:1350:36
     |
1348 |             "total_lines": len(all_lines),
1349 |             "returned": len(recent),
1350 |             "logs": [l.strip() for l in recent],
     |                                    ^
1351 |         }
1352 |     except FileNotFoundError:
     |

S607 Starting a process with a partial executable path
    --> ai-orchestrator/backend/main.py:1405:33
     |
1403 |     # Docker
1404 |     try:
1405 |         result = subprocess.run(["docker", "ps", "-q"], capture_output=True, timeout=5)
     |                                 ^^^^^^^^^^^^^^^^^^^^^^
1406 |         containers = len(result.stdout.decode().strip().split("\n")) if result.stdout else 0
1407 |         status["components"]["docker"] = {"status": "running", "containers": containers}
     |

S104 Possible binding to all interfaces
    --> ai-orchestrator/backend/main.py:1425:27
     |
1423 |     import uvicorn
1424 |
1425 |     uvicorn.run(app, host="0.0.0.0", port=8001)
     |                           ^^^^^^^^^
     |

E501 Line too long (107 > 100)
  --> ai-orchestrator/backend/prompts.py:86:101
   |
84 | - Ai-je fourni un plan d’action exécutable?
85 | - Ai-je éliminé les phrases génériques?
86 | Si une réponse pourrait être donnée par “n’importe quelle IA”, elle est insuffisante: réécris plus concret.
   |                                                                                                     ^^^^^^^
87 |
88 | ## FORMAT D'EXÉCUTION STRICT (ReAct)
   |

E501 Line too long (128 > 100)
   --> ai-orchestrator/backend/prompts.py:119:101
    |
118 | ## 🧠 MÉMOIRE
119 | - Au début d’une conversation ou si le contexte manque: utilise memory_recall(query="contexte utilisateur projets préférences").
    |                                                                                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
120 | - Stocke les faits importants avec memory_store(...).
    |

E501 Line too long (110 > 100)
   --> ai-orchestrator/backend/prompts.py:165:101
    |
164 | 🚨 DERNIÈRE ITÉRATION: conclure immédiatement.
165 | Rappel: ta sortie finale DOIT respecter le format obligatoire (Réponse directe / Hypothèses / Plan / Détails).
    |                                                                                                     ^^^^^^^^^^
166 |
167 | THINK: [Synthétise les faits, choisis la recommandation]
    |

E501 Line too long (102 > 100)
   --> ai-orchestrator/backend/prompts.py:213:101
    |
211 |     uniquement au début d'une conversation si tu veux forcer le recall.
212 |     """
213 |     return """THINK: Nouvelle conversation ou contexte incertain. Je vais d'abord vérifier ma mémoire.
    |                                                                                                     ^^
214 | ACTION: memory_recall(query="contexte utilisateur projets préférences")"""
    |

UP035 `typing.Dict` is deprecated, use `dict` instead
  --> ai-orchestrator/backend/rate_limiter.py:12:1
   |
10 | from collections import defaultdict
11 | from dataclasses import dataclass, field
12 | from typing import Dict, Optional
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
13 |
14 | from fastapi import HTTPException, Request, status
   |

UP045 [*] Use `X | None` for type annotations
  --> ai-orchestrator/backend/rate_limiter.py:63:19
   |
61 |     window_start: float = field(default_factory=time.time)
62 |     violations: int = 0
63 |     banned_until: Optional[float] = None
   |                   ^^^^^^^^^^^^^^^
   |
help: Convert to `X | None`

UP045 [*] Use `X | None` for type annotations
  --> ai-orchestrator/backend/rate_limiter.py:73:18
   |
71 |     remaining: int
72 |     reset_at: float
73 |     retry_after: Optional[int] = None
   |                  ^^^^^^^^^^^^^
   |
help: Convert to `X | None`

UP006 [*] Use `dict` instead of `Dict` for type annotation
  --> ai-orchestrator/backend/rate_limiter.py:83:21
   |
82 |     def __init__(self):
83 |         self._data: Dict[str, RateLimitState] = defaultdict(RateLimitState)
   |                     ^^^^
84 |         self._lock = asyncio.Lock()
   |
help: Replace with `dict`

UP045 [*] Use `X | None` for type annotations
   --> ai-orchestrator/backend/rate_limiter.py:253:42
    |
252 |     async def check_request(
253 |         self, request: Request, user_id: Optional[str] = None
    |                                          ^^^^^^^^^^^^^
254 |     ) -> RateLimitResult:
255 |         """
    |
help: Convert to `X | None`

UP006 [*] Use `dict` instead of `Dict` for type annotation
   --> ai-orchestrator/backend/rate_limiter.py:393:35
    |
393 | def configure_rate_limits(limits: Dict[str, tuple]):
    |                                   ^^^^
394 |     """
395 |     Configurer des limites personnalisées
    |
help: Replace with `dict`

UP006 [*] Use `dict` instead of `Dict` for type annotation
   --> ai-orchestrator/backend/rate_limiter.py:416:37
    |
416 | async def get_rate_limit_stats() -> Dict:
    |                                     ^^^^
417 |     """Obtenir les statistiques du rate limiter"""
418 |     stats = {"total_keys": len(storage._data), "banned_count": 0, "top_violators": []}
    |
help: Replace with `dict`

UP035 `typing.Tuple` is deprecated, use `tuple` instead
  --> ai-orchestrator/backend/security.py:12:1
   |
10 | import shlex
11 | from pathlib import Path
12 | from typing import Optional, Tuple
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
13 |
14 | logger = logging.getLogger(__name__)
   |

S108 Probable insecure usage of temporary file or directory: "/tmp"
   --> ai-orchestrator/backend/security.py:100:5
    |
 98 |     "/home/lalpha/scripts",
 99 |     "/data",
100 |     "/tmp",
    |     ^^^^^^
101 |     "/var/log",
102 |     "/etc/hosts",
    |

S108 Probable insecure usage of temporary file or directory: "/tmp"
   --> ai-orchestrator/backend/security.py:114:5
    |
112 |     "/home/lalpha/scripts",
113 |     "/data",
114 |     "/tmp",
    |     ^^^^^^
115 | ]
    |

B904 Within an `except` clause, raise exceptions with `raise ... from err` or `raise ... from None` to distinguish them from errors in exception handling
   --> ai-orchestrator/backend/security.py:179:9
    |
177 |         resolved = str(path_obj.resolve())
178 |     except Exception:
179 |         raise PathNotAllowedError(f"Chemin invalide: {path}")
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
180 |
181 |     # SECURITE: Verifier si c'est un symlink qui pointe hors des chemins autorises
    |

UP006 [*] Use `tuple` instead of `Tuple` for type annotation
   --> ai-orchestrator/backend/security.py:189:56
    |
189 | def is_path_allowed(path: str, write: bool = False) -> Tuple[bool, str]:
    |                                                        ^^^^^
190 |     """
191 |     Vérifier si un chemin est autorisé
    |
help: Replace with `tuple`

UP045 [*] Use `X | None` for type annotations
   --> ai-orchestrator/backend/security.py:235:47
    |
235 | def check_dangerous_patterns(command: str) -> Optional[str]:
    |                                               ^^^^^^^^^^^^^
236 |     """Vérifier les patterns dangereux dans une commande"""
237 |     for pattern in FORBIDDEN_PATTERNS:
    |
help: Convert to `X | None`

UP006 [*] Use `tuple` instead of `Tuple` for type annotation
   --> ai-orchestrator/backend/security.py:266:39
    |
266 | def validate_command(command: str) -> Tuple[bool, str]:
    |                                       ^^^^^
267 |     """Valider une commande - Mode autonome = blacklist"""
268 |     if not command or not command.strip():
    |
help: Replace with `tuple`

I001 [*] Import block is un-sorted or un-formatted
  --> ai-orchestrator/backend/services/__init__.py:7:1
   |
 5 |   """
 6 |
 7 | / from services.reranker import rerank_documents, hybrid_search_with_rerank, clear_cache as clear_reranker_cache
 8 | | from services.rag_service import RAGService, get_rag_service, RAGResult
   | |_______________________________________________________________________^
 9 |
10 |   __all__ = [
   |
help: Organize imports

E501 Line too long (110 > 100)
 --> ai-orchestrator/backend/services/__init__.py:7:101
  |
5 | """
6 |
7 | from services.reranker import rerank_documents, hybrid_search_with_rerank, clear_cache as clear_reranker_cache
  |                                                                                                     ^^^^^^^^^^
8 | from services.rag_service import RAGService, get_rag_service, RAGResult
  |

I001 [*] Import block is un-sorted or un-formatted
  --> ai-orchestrator/backend/services/rag/__init__.py:33:1
   |
31 |   """
32 |
33 | / from .config import (
34 | |     RAGConfig,
35 | |     get_rag_config,
36 | |     reset_config,
37 | |     EmbeddingModel,
38 | |     RerankerModel,
39 | | )
40 | |
41 | | from .embeddings import (
42 | |     EmbeddingService,
43 | |     EmbeddingResult,
44 | |     get_embedding_service,
45 | |     generate_embedding,
46 | | )
47 | |
48 | | from .reranker import (
49 | |     RerankerService,
50 | |     RerankResult,
51 | |     RerankStats,
52 | |     get_reranker_service,
53 | | )
54 | |
55 | | from .search import (
56 | |     SearchService,
57 | |     SearchResult,
58 | |     SearchResponse,
59 | |     get_search_service,
60 | |     search_documents,
61 | | )
62 | |
63 | | from .indexer import (
64 | |     DocumentIndexer,
65 | |     IndexingResult,
66 | |     IndexingStats,
67 | |     IndexedFile,
68 | |     get_indexer,
69 | | )
70 | |
71 | | from .context_injector import (
72 | |     ContextInjector,
73 | |     InjectionResult,
74 | |     get_context_injector,
75 | |     inject_rag_context,
76 | | )
   | |_^
   |
help: Organize imports

I001 [*] Import block is un-sorted or un-formatted
 --> ai-orchestrator/backend/services/rag/config.py:6:1
  |
4 |   """
5 |
6 | / import os
7 | | from dataclasses import dataclass, field
8 | | from typing import List, Optional
9 | | from enum import Enum
  | |_____________________^
  |
help: Organize imports

UP035 `typing.List` is deprecated, use `list` instead
 --> ai-orchestrator/backend/services/rag/config.py:8:1
  |
6 | import os
7 | from dataclasses import dataclass, field
8 | from typing import List, Optional
  | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
9 | from enum import Enum
  |

F401 [*] `typing.List` imported but unused
 --> ai-orchestrator/backend/services/rag/config.py:8:20
  |
6 | import os
7 | from dataclasses import dataclass, field
8 | from typing import List, Optional
  |                    ^^^^
9 | from enum import Enum
  |
help: Remove unused import: `typing.List`

E501 Line too long (119 > 100)
  --> ai-orchestrator/backend/services/rag/config.py:35:101
   |
34 |     # === Modèles ===
35 |     embedding_model: str = field(default_factory=lambda: os.getenv("RAG_EMBEDDING_MODEL", EmbeddingModel.BGE_M3.value))
   |                                                                                                     ^^^^^^^^^^^^^^^^^^^
36 |     reranker_model: str = field(default_factory=lambda: os.getenv("RAG_RERANKER_MODEL", RerankerModel.BGE_RERANKER_V2.value))
   |

E501 Line too long (125 > 100)
  --> ai-orchestrator/backend/services/rag/config.py:36:101
   |
34 |     # === Modèles ===
35 |     embedding_model: str = field(default_factory=lambda: os.getenv("RAG_EMBEDDING_MODEL", EmbeddingModel.BGE_M3.value))
36 |     reranker_model: str = field(default_factory=lambda: os.getenv("RAG_RERANKER_MODEL", RerankerModel.BGE_RERANKER_V2.value))
   |                                                                                                     ^^^^^^^^^^^^^^^^^^^^^^^^^
37 |     
38 |     # === Collection ===
   |

E501 Line too long (114 > 100)
  --> ai-orchestrator/backend/services/rag/config.py:39:101
   |
38 |     # === Collection ===
39 |     collection_name: str = field(default_factory=lambda: os.getenv("RAG_COLLECTION", "ai_orchestrator_memory_v3"))
   |                                                                                                     ^^^^^^^^^^^^^^
40 |     
41 |     # === Embedding ===
   |

UP045 [*] Use `X | None` for type annotations
   --> ai-orchestrator/backend/services/rag/config.py:102:10
    |
101 | # Instance globale de configuration
102 | _config: Optional[RAGConfig] = None
    |          ^^^^^^^^^^^^^^^^^^^
    |
help: Convert to `X | None`

I001 [*] Import block is un-sorted or un-formatted
  --> ai-orchestrator/backend/services/rag/context_injector.py:6:1
   |
 4 |   """
 5 |
 6 | / import asyncio
 7 | | import logging
 8 | | import re
 9 | | from dataclasses import dataclass
10 | | from typing import Dict, List, Optional, Tuple
11 | | from datetime import datetime
12 | |
13 | | from .config import get_rag_config, RAGConfig
14 | | from .search import get_search_service, SearchService, SearchResult
   | |___________________________________________________________________^
15 |
16 |   logger = logging.getLogger("rag.context_injector")
   |
help: Organize imports

F401 [*] `asyncio` imported but unused
 --> ai-orchestrator/backend/services/rag/context_injector.py:6:8
  |
4 | """
5 |
6 | import asyncio
  |        ^^^^^^^
7 | import logging
8 | import re
  |
help: Remove unused import: `asyncio`

UP035 `typing.Dict` is deprecated, use `dict` instead
  --> ai-orchestrator/backend/services/rag/context_injector.py:10:1
   |
 8 | import re
 9 | from dataclasses import dataclass
10 | from typing import Dict, List, Optional, Tuple
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
11 | from datetime import datetime
   |

UP035 `typing.List` is deprecated, use `list` instead
  --> ai-orchestrator/backend/services/rag/context_injector.py:10:1
   |
 8 | import re
 9 | from dataclasses import dataclass
10 | from typing import Dict, List, Optional, Tuple
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
11 | from datetime import datetime
   |

UP035 `typing.Tuple` is deprecated, use `tuple` instead
  --> ai-orchestrator/backend/services/rag/context_injector.py:10:1
   |
 8 | import re
 9 | from dataclasses import dataclass
10 | from typing import Dict, List, Optional, Tuple
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
11 | from datetime import datetime
   |

F401 [*] `typing.Dict` imported but unused
  --> ai-orchestrator/backend/services/rag/context_injector.py:10:20
   |
 8 | import re
 9 | from dataclasses import dataclass
10 | from typing import Dict, List, Optional, Tuple
   |                    ^^^^
11 | from datetime import datetime
   |
help: Remove unused import: `typing.Dict`

UP045 [*] Use `X | None` for type annotations
  --> ai-orchestrator/backend/services/rag/context_injector.py:22:14
   |
20 | class InjectionResult:
21 |     """Résultat d'une injection de contexte"""
22 |     context: Optional[str]
   |              ^^^^^^^^^^^^^
23 |     sources: List[str]
24 |     relevance_score: float
   |
help: Convert to `X | None`

UP006 [*] Use `list` instead of `List` for type annotation
  --> ai-orchestrator/backend/services/rag/context_injector.py:23:14
   |
21 |     """Résultat d'une injection de contexte"""
22 |     context: Optional[str]
23 |     sources: List[str]
   |              ^^^^
24 |     relevance_score: float
25 |     search_time_ms: float
   |
help: Replace with `list`

UP045 [*] Use `X | None` for type annotations
  --> ai-orchestrator/backend/services/rag/context_injector.py:39:17
   |
37 |     def __init__(
38 |         self,
39 |         config: Optional[RAGConfig] = None,
   |                 ^^^^^^^^^^^^^^^^^^^
40 |         search_service: Optional[SearchService] = None
41 |     ):
   |
help: Convert to `X | None`

UP045 [*] Use `X | None` for type annotations
  --> ai-orchestrator/backend/services/rag/context_injector.py:40:25
   |
38 |         self,
39 |         config: Optional[RAGConfig] = None,
40 |         search_service: Optional[SearchService] = None
   |                         ^^^^^^^^^^^^^^^^^^^^^^^
41 |     ):
42 |         self.config = config or get_rag_config()
   |
help: Convert to `X | None`

UP006 [*] Use `list` instead of `List` for type annotation
  --> ai-orchestrator/backend/services/rag/context_injector.py:80:48
   |
78 |         return True
79 |     
80 |     def _extract_keywords(self, query: str) -> List[str]:
   |                                                ^^^^
81 |         """
82 |         Extrait les mots-clés importants de la requête.
   |
help: Replace with `list`

UP006 [*] Use `list` instead of `List` for type annotation
   --> ai-orchestrator/backend/services/rag/context_injector.py:107:40
    |
105 |         return keywords
106 |     
107 |     def _format_context(self, results: List[SearchResult]) -> str:
    |                                        ^^^^
108 |         """
109 |         Formate les résultats de recherche en contexte injecté.
    |
help: Replace with `list`

B007 Loop control variable `i` not used within loop body
   --> ai-orchestrator/backend/services/rag/context_injector.py:116:13
    |
114 |         parts = ["## 📚 Contexte de la base de connaissances:\n"]
115 |         
116 |         for i, result in enumerate(results, 1):
    |             ^
117 |             # Tronquer le contenu si nécessaire
118 |             content = result.content
    |
help: Rename unused `i` to `_i`

E501 Line too long (105 > 100)
   --> ai-orchestrator/backend/services/rag/context_injector.py:182:101
    |
181 |             if not relevant_results:
182 |                 logger.debug(f"Pas de résultats assez pertinents (min: {self.config.context_min_score})")
    |                                                                                                     ^^^^^
183 |                 return InjectionResult(
184 |                     context=None,
    |

E501 Line too long (104 > 100)
   --> ai-orchestrator/backend/services/rag/context_injector.py:203:101
    |
201 |             sources = [r.source for r in relevant_results]
202 |             
203 |             logger.info(f"Contexte injecté: {len(relevant_results)} docs, score moyen: {avg_score:.2f}")
    |                                                                                                     ^^^^
204 |             
205 |             return InjectionResult(
    |

UP006 [*] Use `tuple` instead of `Tuple` for type annotation
   --> ai-orchestrator/backend/services/rag/context_injector.py:227:10
    |
225 |         system_prompt: str,
226 |         user_query: str
227 |     ) -> Tuple[str, InjectionResult]:
    |          ^^^^^
228 |         """
229 |         Injecte le contexte RAG dans le prompt système.
    |
help: Replace with `tuple`

UP045 [*] Use `X | None` for type annotations
   --> ai-orchestrator/backend/services/rag/context_injector.py:250:20
    |
249 | # Singleton
250 | _context_injector: Optional[ContextInjector] = None
    |                    ^^^^^^^^^^^^^^^^^^^^^^^^^
    |
help: Convert to `X | None`

UP006 [*] Use `tuple` instead of `Tuple` for type annotation
   --> ai-orchestrator/backend/services/rag/context_injector.py:264:6
    |
262 |     system_prompt: str,
263 |     user_query: str
264 | ) -> Tuple[str, InjectionResult]:
    |      ^^^^^
265 |     """
266 |     Fonction utilitaire pour injecter le contexte RAG.
    |
help: Replace with `tuple`

I001 [*] Import block is un-sorted or un-formatted
  --> ai-orchestrator/backend/services/rag/embeddings.py:6:1
   |
 4 |   """
 5 |
 6 | / import asyncio
 7 | | import hashlib
 8 | | import logging
 9 | | from collections import OrderedDict
10 | | from dataclasses import dataclass
11 | | from typing import Dict, List, Optional, Tuple
12 | | from datetime import datetime
13 | |
14 | | import httpx
15 | |
16 | | from .config import get_rag_config, RAGConfig
   | |_____________________________________________^
17 |
18 |   logger = logging.getLogger("rag.embeddings")
   |
help: Organize imports

F401 [*] `hashlib` imported but unused
 --> ai-orchestrator/backend/services/rag/embeddings.py:7:8
  |
6 | import asyncio
7 | import hashlib
  |        ^^^^^^^
8 | import logging
9 | from collections import OrderedDict
  |
help: Remove unused import: `hashlib`

UP035 `typing.Dict` is deprecated, use `dict` instead
  --> ai-orchestrator/backend/services/rag/embeddings.py:11:1
   |
 9 | from collections import OrderedDict
10 | from dataclasses import dataclass
11 | from typing import Dict, List, Optional, Tuple
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
12 | from datetime import datetime
   |

UP035 `typing.List` is deprecated, use `list` instead
  --> ai-orchestrator/backend/services/rag/embeddings.py:11:1
   |
 9 | from collections import OrderedDict
10 | from dataclasses import dataclass
11 | from typing import Dict, List, Optional, Tuple
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
12 | from datetime import datetime
   |

UP035 `typing.Tuple` is deprecated, use `tuple` instead
  --> ai-orchestrator/backend/services/rag/embeddings.py:11:1
   |
 9 | from collections import OrderedDict
10 | from dataclasses import dataclass
11 | from typing import Dict, List, Optional, Tuple
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
12 | from datetime import datetime
   |

F401 [*] `typing.Tuple` imported but unused
  --> ai-orchestrator/backend/services/rag/embeddings.py:11:42
   |
 9 | from collections import OrderedDict
10 | from dataclasses import dataclass
11 | from typing import Dict, List, Optional, Tuple
   |                                          ^^^^^
12 | from datetime import datetime
   |
help: Remove unused import: `typing.Tuple`

UP006 [*] Use `list` instead of `List` for type annotation
  --> ai-orchestrator/backend/services/rag/embeddings.py:24:16
   |
22 | class EmbeddingResult:
23 |     """Résultat d'une génération d'embedding"""
24 |     embedding: List[float]
   |                ^^^^
25 |     model: str
26 |     cached: bool
   |
help: Replace with `list`

UP006 [*] Use `list` instead of `List` for type annotation
  --> ai-orchestrator/backend/services/rag/embeddings.py:35:39
   |
33 |     def __init__(self, max_size: int = 1000):
34 |         self.max_size = max_size
35 |         self._cache: OrderedDict[int, List[float]] = OrderedDict()
   |                                       ^^^^
36 |         self._hits = 0
37 |         self._misses = 0
   |
help: Replace with `list`

UP045 [*] Use `X | None` for type annotations
  --> ai-orchestrator/backend/services/rag/embeddings.py:39:32
   |
37 |         self._misses = 0
38 |     
39 |     def get(self, key: int) -> Optional[List[float]]:
   |                                ^^^^^^^^^^^^^^^^^^^^^
40 |         """Récupère un embedding du cache"""
41 |         if key in self._cache:
   |
help: Convert to `X | None`

UP006 [*] Use `list` instead of `List` for type annotation
  --> ai-orchestrator/backend/services/rag/embeddings.py:39:41
   |
37 |         self._misses = 0
38 |     
39 |     def get(self, key: int) -> Optional[List[float]]:
   |                                         ^^^^
40 |         """Récupère un embedding du cache"""
41 |         if key in self._cache:
   |
help: Replace with `list`

UP006 [*] Use `list` instead of `List` for type annotation
  --> ai-orchestrator/backend/services/rag/embeddings.py:48:36
   |
46 |         return None
47 |     
48 |     def put(self, key: int, value: List[float]):
   |                                    ^^^^
49 |         """Ajoute un embedding au cache"""
50 |         if key in self._cache:
   |
help: Replace with `list`

UP006 [*] Use `dict` instead of `Dict` for type annotation
  --> ai-orchestrator/backend/services/rag/embeddings.py:64:24
   |
63 |     @property
64 |     def stats(self) -> Dict:
   |                        ^^^^
65 |         """Statistiques du cache"""
66 |         total = self._hits + self._misses
   |
help: Replace with `dict`

UP045 [*] Use `X | None` for type annotations
  --> ai-orchestrator/backend/services/rag/embeddings.py:80:32
   |
78 |     """Service de génération d'embeddings avec cache"""
79 |     
80 |     def __init__(self, config: Optional[RAGConfig] = None):
   |                                ^^^^^^^^^^^^^^^^^^^
81 |         self.config = config or get_rag_config()
82 |         self._cache = LRUCache(max_size=self.config.embedding_cache_size)
   |
help: Convert to `X | None`

UP045 [*] Use `X | None` for type annotations
  --> ai-orchestrator/backend/services/rag/embeddings.py:83:23
   |
81 |         self.config = config or get_rag_config()
82 |         self._cache = LRUCache(max_size=self.config.embedding_cache_size)
83 |         self._client: Optional[httpx.AsyncClient] = None
   |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^
84 |         self._total_generations = 0
85 |         self._total_time_ms = 0.0
   |
help: Convert to `X | None`

UP045 [*] Use `X | None` for type annotations
   --> ai-orchestrator/backend/services/rag/embeddings.py:99:68
    |
 97 |         return hash(normalized)
 98 |     
 99 |     async def generate(self, text: str, use_cache: bool = True) -> Optional[EmbeddingResult]:
    |                                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^
100 |         """
101 |         Génère un embedding pour le texte donné.
    |
help: Convert to `X | None`

E501 Line too long (105 > 100)
   --> ai-orchestrator/backend/services/rag/embeddings.py:172:101
    |
171 |         except httpx.TimeoutException:
172 |             logger.error(f"Timeout lors de la génération d'embedding ({self.config.embedding_timeout}s)")
    |                                                                                                     ^^^^^
173 |             return None
174 |         except Exception as e:
    |

UP006 [*] Use `list` instead of `List` for type annotation
   --> ai-orchestrator/backend/services/rag/embeddings.py:178:43
    |
176 |             return None
177 |     
178 |     async def generate_batch(self, texts: List[str], use_cache: bool = True) -> List[Optional[EmbeddingResult]]:
    |                                           ^^^^
179 |         """
180 |         Génère des embeddings pour plusieurs textes.
    |
help: Replace with `list`

UP006 [*] Use `list` instead of `List` for type annotation
   --> ai-orchestrator/backend/services/rag/embeddings.py:178:81
    |
176 |             return None
177 |     
178 |     async def generate_batch(self, texts: List[str], use_cache: bool = True) -> List[Optional[EmbeddingResult]]:
    |                                                                                 ^^^^
179 |         """
180 |         Génère des embeddings pour plusieurs textes.
    |
help: Replace with `list`

UP045 [*] Use `X | None` for type annotations
   --> ai-orchestrator/backend/services/rag/embeddings.py:178:86
    |
176 |             return None
177 |     
178 |     async def generate_batch(self, texts: List[str], use_cache: bool = True) -> List[Optional[EmbeddingResult]]:
    |                                                                                      ^^^^^^^^^^^^^^^^^^^^^^^^^
179 |         """
180 |         Génère des embeddings pour plusieurs textes.
    |
help: Convert to `X | None`

E501 Line too long (112 > 100)
   --> ai-orchestrator/backend/services/rag/embeddings.py:178:101
    |
176 |             return None
177 |     
178 |     async def generate_batch(self, texts: List[str], use_cache: bool = True) -> List[Optional[EmbeddingResult]]:
    |                                                                                                     ^^^^^^^^^^^^
179 |         """
180 |         Génère des embeddings pour plusieurs textes.
    |

UP006 [*] Use `dict` instead of `Dict` for type annotation
   --> ai-orchestrator/backend/services/rag/embeddings.py:198:24
    |
197 |     @property
198 |     def stats(self) -> Dict:
    |                        ^^^^
199 |         """Statistiques du service"""
200 |         avg_time = (self._total_time_ms / self._total_generations) if self._total_generations > 0 else 0
    |
help: Replace with `dict`

E501 Line too long (104 > 100)
   --> ai-orchestrator/backend/services/rag/embeddings.py:200:101
    |
198 |     def stats(self) -> Dict:
199 |         """Statistiques du service"""
200 |         avg_time = (self._total_time_ms / self._total_generations) if self._total_generations > 0 else 0
    |                                                                                                     ^^^^
201 |         return {
202 |             "model": self.config.embedding_model,
    |

UP045 [*] Use `X | None` for type annotations
   --> ai-orchestrator/backend/services/rag/embeddings.py:216:21
    |
215 | # Singleton du service
216 | _embedding_service: Optional[EmbeddingService] = None
    |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^
    |
help: Convert to `X | None`

UP045 [*] Use `X | None` for type annotations
   --> ai-orchestrator/backend/services/rag/embeddings.py:227:68
    |
227 | async def generate_embedding(text: str, use_cache: bool = True) -> Optional[List[float]]:
    |                                                                    ^^^^^^^^^^^^^^^^^^^^^
228 |     """
229 |     Fonction utilitaire pour générer un embedding.
    |
help: Convert to `X | None`

UP006 [*] Use `list` instead of `List` for type annotation
   --> ai-orchestrator/backend/services/rag/embeddings.py:227:77
    |
227 | async def generate_embedding(text: str, use_cache: bool = True) -> Optional[List[float]]:
    |                                                                             ^^^^
228 |     """
229 |     Fonction utilitaire pour générer un embedding.
    |
help: Replace with `list`

I001 [*] Import block is un-sorted or un-formatted
  --> ai-orchestrator/backend/services/rag/indexer.py:6:1
   |
 4 |   """
 5 |
 6 | / import asyncio
 7 | | import hashlib
 8 | | import json
 9 | | import logging
10 | | import os
11 | | import re
12 | | from dataclasses import dataclass, asdict
13 | | from datetime import datetime
14 | | from pathlib import Path
15 | | from typing import Dict, List, Optional, Set
16 | |
17 | | import httpx
18 | |
19 | | from .config import get_rag_config, RAGConfig
20 | | from .embeddings import get_embedding_service
   | |_____________________________________________^
21 |
22 |   logger = logging.getLogger("rag.indexer")
   |
help: Organize imports

F401 [*] `asyncio` imported but unused
 --> ai-orchestrator/backend/services/rag/indexer.py:6:8
  |
4 | """
5 |
6 | import asyncio
  |        ^^^^^^^
7 | import hashlib
8 | import json
  |
help: Remove unused import: `asyncio`

UP035 `typing.Dict` is deprecated, use `dict` instead
  --> ai-orchestrator/backend/services/rag/indexer.py:15:1
   |
13 | from datetime import datetime
14 | from pathlib import Path
15 | from typing import Dict, List, Optional, Set
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
16 |
17 | import httpx
   |

UP035 `typing.List` is deprecated, use `list` instead
  --> ai-orchestrator/backend/services/rag/indexer.py:15:1
   |
13 | from datetime import datetime
14 | from pathlib import Path
15 | from typing import Dict, List, Optional, Set
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
16 |
17 | import httpx
   |

UP035 `typing.Set` is deprecated, use `set` instead
  --> ai-orchestrator/backend/services/rag/indexer.py:15:1
   |
13 | from datetime import datetime
14 | from pathlib import Path
15 | from typing import Dict, List, Optional, Set
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
16 |
17 | import httpx
   |

UP045 [*] Use `X | None` for type annotations
  --> ai-orchestrator/backend/services/rag/indexer.py:41:12
   |
39 |     success: bool
40 |     chunks_indexed: int
41 |     error: Optional[str] = None
   |            ^^^^^^^^^^^^^
   |
help: Convert to `X | None`

UP006 [*] Use `dict` instead of `Dict` for type annotation
  --> ai-orchestrator/backend/services/rag/indexer.py:61:22
   |
59 |     def __init__(self, tracking_file: str):
60 |         self.tracking_file = tracking_file
61 |         self._index: Dict[str, IndexedFile] = {}
   |                      ^^^^
62 |         self._load()
   |
help: Replace with `dict`

UP015 [*] Unnecessary mode argument
  --> ai-orchestrator/backend/services/rag/indexer.py:68:47
   |
66 |         try:
67 |             if os.path.exists(self.tracking_file):
68 |                 with open(self.tracking_file, 'r') as f:
   |                                               ^^^
69 |                     data = json.load(f)
70 |                     for filepath, info in data.items():
   |
help: Remove mode argument

UP045 [*] Use `X | None` for type annotations
  --> ai-orchestrator/backend/services/rag/indexer.py:87:47
   |
85 |             logger.error(f"Erreur sauvegarde index: {e}")
86 |     
87 |     def get_file_info(self, filepath: str) -> Optional[IndexedFile]:
   |                                               ^^^^^^^^^^^^^^^^^^^^^
88 |         """Récupère les infos d'un fichier indexé"""
89 |         return self._index.get(filepath)
   |
help: Convert to `X | None`

UP006 [*] Use `set` instead of `Set` for type annotation
   --> ai-orchestrator/backend/services/rag/indexer.py:116:32
    |
115 |     @property
116 |     def tracked_files(self) -> Set[str]:
    |                                ^^^
117 |         """Ensemble des fichiers trackés"""
118 |         return set(self._index.keys())
    |
help: Replace with `set`

UP045 [*] Use `X | None` for type annotations
   --> ai-orchestrator/backend/services/rag/indexer.py:132:32
    |
130 |     """
131 |     
132 |     def __init__(self, config: Optional[RAGConfig] = None):
    |                                ^^^^^^^^^^^^^^^^^^^
133 |         self.config = config or get_rag_config()
134 |         self._embedding_service = None
    |
help: Convert to `X | None`

UP045 [*] Use `X | None` for type annotations
   --> ai-orchestrator/backend/services/rag/indexer.py:135:23
    |
133 |         self.config = config or get_rag_config()
134 |         self._embedding_service = None
135 |         self._client: Optional[httpx.AsyncClient] = None
    |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^
136 |         self._collection_id: Optional[str] = None
137 |         self._tracker = IndexTracker(self.config.index_tracking_file)
    |
help: Convert to `X | None`

UP045 [*] Use `X | None` for type annotations
   --> ai-orchestrator/backend/services/rag/indexer.py:136:30
    |
134 |         self._embedding_service = None
135 |         self._client: Optional[httpx.AsyncClient] = None
136 |         self._collection_id: Optional[str] = None
    |                              ^^^^^^^^^^^^^
137 |         self._tracker = IndexTracker(self.config.index_tracking_file)
    |
help: Convert to `X | None`

UP045 [*] Use `X | None` for type annotations
   --> ai-orchestrator/backend/services/rag/indexer.py:150:43
    |
148 |         return self._client
149 |     
150 |     async def _get_collection_id(self) -> Optional[str]:
    |                                           ^^^^^^^^^^^^^
151 |         """Récupère l'ID de la collection"""
152 |         if self._collection_id:
    |
help: Convert to `X | None`

S324 Probable use of insecure hash functions in `hashlib`: `md5`
   --> ai-orchestrator/backend/services/rag/indexer.py:173:16
    |
171 |     def _compute_file_hash(self, content: str) -> str:
172 |         """Calcule le hash MD5 du contenu"""
173 |         return hashlib.md5(content.encode('utf-8')).hexdigest()
    |                ^^^^^^^^^^^
174 |     
175 |     def _chunk_document(self, content: str) -> List[Dict]:
    |

UP006 [*] Use `list` instead of `List` for type annotation
   --> ai-orchestrator/backend/services/rag/indexer.py:175:48
    |
173 |         return hashlib.md5(content.encode('utf-8')).hexdigest()
174 |     
175 |     def _chunk_document(self, content: str) -> List[Dict]:
    |                                                ^^^^
176 |         """
177 |         Découpe un document en chunks avec overlap.
    |
help: Replace with `list`

UP006 [*] Use `dict` instead of `Dict` for type annotation
   --> ai-orchestrator/backend/services/rag/indexer.py:175:53
    |
173 |         return hashlib.md5(content.encode('utf-8')).hexdigest()
174 |     
175 |     def _chunk_document(self, content: str) -> List[Dict]:
    |                                                     ^^^^
176 |         """
177 |         Découpe un document en chunks avec overlap.
    |
help: Replace with `dict`

E501 Line too long (111 > 100)
   --> ai-orchestrator/backend/services/rag/indexer.py:231:101
    |
229 |                                 })
230 |                                 chunk_index += 1
231 |                             temp_chunk = temp_chunk[-overlap_chars:] if len(temp_chunk) > overlap_chars else ""
    |                                                                                                     ^^^^^^^^^^^
232 |                         temp_chunk += " " + word
233 |                     current_chunk = temp_chunk
    |

S324 Probable use of insecure hash functions in `hashlib`: `md5`
   --> ai-orchestrator/backend/services/rag/indexer.py:322:30
    |
321 |             for chunk in chunks:
322 |                 chunk_hash = hashlib.md5(chunk["content"][:200].encode()).hexdigest()[:8]
    |                              ^^^^^^^^^^^
323 |                 doc_id = f"doc_{filename}_{chunk['index']}_{chunk_hash}"
    |

UP006 [*] Use `list` instead of `List` for type annotation
   --> ai-orchestrator/backend/services/rag/indexer.py:373:19
    |
371 |         self,
372 |         directory: str,
373 |         patterns: List[str] = ["*.md", "*.txt"],
    |                   ^^^^
374 |         force: bool = False
375 |     ) -> IndexingStats:
    |
help: Replace with `list`

B006 Do not use mutable data structures for argument defaults
   --> ai-orchestrator/backend/services/rag/indexer.py:373:31
    |
371 |         self,
372 |         directory: str,
373 |         patterns: List[str] = ["*.md", "*.txt"],
    |                               ^^^^^^^^^^^^^^^^^
374 |         force: bool = False
375 |     ) -> IndexingStats:
    |
help: Replace with `None`; initialize within function

UP045 [*] Use `X | None` for type annotations
   --> ai-orchestrator/backend/services/rag/indexer.py:443:11
    |
442 | # Singleton
443 | _indexer: Optional[DocumentIndexer] = None
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^
    |
help: Convert to `X | None`

I001 [*] Import block is un-sorted or un-formatted
  --> ai-orchestrator/backend/services/rag/reranker.py:6:1
   |
 4 |   """
 5 |
 6 | / import asyncio
 7 | | import logging
 8 | | import math
 9 | | from dataclasses import dataclass
10 | | from typing import Dict, List, Optional, Tuple
11 | | from datetime import datetime
12 | |
13 | | import httpx
14 | |
15 | | from .config import get_rag_config, RAGConfig, RerankerModel
   | |____________________________________________________________^
16 |
17 |   logger = logging.getLogger("rag.reranker")
   |
help: Organize imports

F401 [*] `math` imported but unused
  --> ai-orchestrator/backend/services/rag/reranker.py:8:8
   |
 6 | import asyncio
 7 | import logging
 8 | import math
   |        ^^^^
 9 | from dataclasses import dataclass
10 | from typing import Dict, List, Optional, Tuple
   |
help: Remove unused import: `math`

UP035 `typing.Dict` is deprecated, use `dict` instead
  --> ai-orchestrator/backend/services/rag/reranker.py:10:1
   |
 8 | import math
 9 | from dataclasses import dataclass
10 | from typing import Dict, List, Optional, Tuple
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
11 | from datetime import datetime
   |

UP035 `typing.List` is deprecated, use `list` instead
  --> ai-orchestrator/backend/services/rag/reranker.py:10:1
   |
 8 | import math
 9 | from dataclasses import dataclass
10 | from typing import Dict, List, Optional, Tuple
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
11 | from datetime import datetime
   |

UP035 `typing.Tuple` is deprecated, use `tuple` instead
  --> ai-orchestrator/backend/services/rag/reranker.py:10:1
   |
 8 | import math
 9 | from dataclasses import dataclass
10 | from typing import Dict, List, Optional, Tuple
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
11 | from datetime import datetime
   |

UP006 [*] Use `dict` instead of `Dict` for type annotation
  --> ai-orchestrator/backend/services/rag/reranker.py:24:15
   |
22 |     """Résultat d'un document après reranking"""
23 |     content: str
24 |     metadata: Dict
   |               ^^^^
25 |     original_score: float
26 |     rerank_score: float
   |
help: Replace with `dict`

UP045 [*] Use `X | None` for type annotations
  --> ai-orchestrator/backend/services/rag/reranker.py:47:32
   |
45 |     """
46 |     
47 |     def __init__(self, config: Optional[RAGConfig] = None):
   |                                ^^^^^^^^^^^^^^^^^^^
48 |         self.config = config or get_rag_config()
49 |         self._client: Optional[httpx.AsyncClient] = None
   |
help: Convert to `X | None`

UP045 [*] Use `X | None` for type annotations
  --> ai-orchestrator/backend/services/rag/reranker.py:49:23
   |
47 |     def __init__(self, config: Optional[RAGConfig] = None):
48 |         self.config = config or get_rag_config()
49 |         self._client: Optional[httpx.AsyncClient] = None
   |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^
50 |         self._total_reranks = 0
51 |         self._total_time_ms = 0.0
   |
help: Convert to `X | None`

UP006 [*] Use `list` instead of `List` for type annotation
   --> ai-orchestrator/backend/services/rag/reranker.py:119:20
    |
117 |         self,
118 |         query: str,
119 |         documents: List[Tuple[str, Dict, float]],
    |                    ^^^^
120 |         top_k: Optional[int] = None
121 |     ) -> Tuple[List[RerankResult], RerankStats]:
    |
help: Replace with `list`

UP006 [*] Use `tuple` instead of `Tuple` for type annotation
   --> ai-orchestrator/backend/services/rag/reranker.py:119:25
    |
117 |         self,
118 |         query: str,
119 |         documents: List[Tuple[str, Dict, float]],
    |                         ^^^^^
120 |         top_k: Optional[int] = None
121 |     ) -> Tuple[List[RerankResult], RerankStats]:
    |
help: Replace with `tuple`

UP006 [*] Use `dict` instead of `Dict` for type annotation
   --> ai-orchestrator/backend/services/rag/reranker.py:119:36
    |
117 |         self,
118 |         query: str,
119 |         documents: List[Tuple[str, Dict, float]],
    |                                    ^^^^
120 |         top_k: Optional[int] = None
121 |     ) -> Tuple[List[RerankResult], RerankStats]:
    |
help: Replace with `dict`

UP045 [*] Use `X | None` for type annotations
   --> ai-orchestrator/backend/services/rag/reranker.py:120:16
    |
118 |         query: str,
119 |         documents: List[Tuple[str, Dict, float]],
120 |         top_k: Optional[int] = None
    |                ^^^^^^^^^^^^^
121 |     ) -> Tuple[List[RerankResult], RerankStats]:
122 |         """
    |
help: Convert to `X | None`

UP006 [*] Use `tuple` instead of `Tuple` for type annotation
   --> ai-orchestrator/backend/services/rag/reranker.py:121:10
    |
119 |         documents: List[Tuple[str, Dict, float]],
120 |         top_k: Optional[int] = None
121 |     ) -> Tuple[List[RerankResult], RerankStats]:
    |          ^^^^^
122 |         """
123 |         Réordonne les documents par pertinence.
    |
help: Replace with `tuple`

UP006 [*] Use `list` instead of `List` for type annotation
   --> ai-orchestrator/backend/services/rag/reranker.py:121:16
    |
119 |         documents: List[Tuple[str, Dict, float]],
120 |         top_k: Optional[int] = None
121 |     ) -> Tuple[List[RerankResult], RerankStats]:
    |                ^^^^
122 |         """
123 |         Réordonne les documents par pertinence.
    |
help: Replace with `list`

B007 Loop control variable `metadata` not used within loop body
   --> ai-orchestrator/backend/services/rag/reranker.py:141:22
    |
139 |         # Calculer les scores de reranking en parallèle
140 |         rerank_tasks = []
141 |         for content, metadata, distance in documents:
    |                      ^^^^^^^^
142 |             if self._enabled:
143 |                 task = self._compute_rerank_score(query, content)
    |
help: Rename unused `metadata` to `_metadata`

B905 `zip()` without an explicit `strict=` parameter
   --> ai-orchestrator/backend/services/rag/reranker.py:152:60
    |
151 |         # Combiner les scores
152 |         for (content, metadata, distance), rerank_score in zip(documents, rerank_scores):
    |                                                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
153 |             similarity_score = self._distance_to_similarity(distance)
    |
help: Add explicit value for parameter `strict=`

E501 Line too long (101 > 100)
   --> ai-orchestrator/backend/services/rag/reranker.py:190:101
    |
188 |         )
189 |         
190 |         logger.debug(f"Reranked {len(documents)} -> {len(final_results)} docs in {elapsed_ms:.0f}ms")
    |                                                                                                     ^
191 |         
192 |         return final_results, stats
    |

UP006 [*] Use `dict` instead of `Dict` for type annotation
   --> ai-orchestrator/backend/services/rag/reranker.py:195:24
    |
194 |     @property
195 |     def stats(self) -> Dict:
    |                        ^^^^
196 |         """Statistiques du service"""
197 |         avg_time = (self._total_time_ms / self._total_reranks) if self._total_reranks > 0 else 0
    |
help: Replace with `dict`

UP045 [*] Use `X | None` for type annotations
   --> ai-orchestrator/backend/services/rag/reranker.py:212:20
    |
211 | # Singleton
212 | _reranker_service: Optional[RerankerService] = None
    |                    ^^^^^^^^^^^^^^^^^^^^^^^^^
    |
help: Convert to `X | None`

I001 [*] Import block is un-sorted or un-formatted
  --> ai-orchestrator/backend/services/rag/search.py:6:1
   |
 4 |   """
 5 |
 6 | / import asyncio
 7 | | import logging
 8 | | import re
 9 | | from dataclasses import dataclass, field
10 | | from typing import Dict, List, Optional, Tuple
11 | | from datetime import datetime
12 | |
13 | | import httpx
14 | |
15 | | from .config import get_rag_config, RAGConfig
16 | | from .embeddings import get_embedding_service, EmbeddingService
17 | | from .reranker import get_reranker_service, RerankerService, RerankResult
   | |_________________________________________________________________________^
18 |
19 |   logger = logging.getLogger("rag.search")
   |
help: Organize imports

F401 [*] `asyncio` imported but unused
 --> ai-orchestrator/backend/services/rag/search.py:6:8
  |
4 | """
5 |
6 | import asyncio
  |        ^^^^^^^
7 | import logging
8 | import re
  |
help: Remove unused import: `asyncio`

F401 [*] `dataclasses.field` imported but unused
  --> ai-orchestrator/backend/services/rag/search.py:9:36
   |
 7 | import logging
 8 | import re
 9 | from dataclasses import dataclass, field
   |                                    ^^^^^
10 | from typing import Dict, List, Optional, Tuple
11 | from datetime import datetime
   |
help: Remove unused import: `dataclasses.field`

UP035 `typing.Dict` is deprecated, use `dict` instead
  --> ai-orchestrator/backend/services/rag/search.py:10:1
   |
 8 | import re
 9 | from dataclasses import dataclass, field
10 | from typing import Dict, List, Optional, Tuple
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
11 | from datetime import datetime
   |

UP035 `typing.List` is deprecated, use `list` instead
  --> ai-orchestrator/backend/services/rag/search.py:10:1
   |
 8 | import re
 9 | from dataclasses import dataclass, field
10 | from typing import Dict, List, Optional, Tuple
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
11 | from datetime import datetime
   |

UP035 `typing.Tuple` is deprecated, use `tuple` instead
  --> ai-orchestrator/backend/services/rag/search.py:10:1
   |
 8 | import re
 9 | from dataclasses import dataclass, field
10 | from typing import Dict, List, Optional, Tuple
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
11 | from datetime import datetime
   |

F401 [*] `.reranker.RerankResult` imported but unused
  --> ai-orchestrator/backend/services/rag/search.py:17:62
   |
15 | from .config import get_rag_config, RAGConfig
16 | from .embeddings import get_embedding_service, EmbeddingService
17 | from .reranker import get_reranker_service, RerankerService, RerankResult
   |                                                              ^^^^^^^^^^^^
18 |
19 | logger = logging.getLogger("rag.search")
   |
help: Remove unused import: `.reranker.RerankResult`

UP045 [*] Use `X | None` for type annotations
  --> ai-orchestrator/backend/services/rag/search.py:32:19
   |
30 |     total_chunks: int
31 |     score: float
32 |     rerank_score: Optional[float] = None
   |                   ^^^^^^^^^^^^^^^
33 |     
34 |     def to_context_string(self) -> str:
   |
help: Convert to `X | None`

UP006 [*] Use `list` instead of `List` for type annotation
  --> ai-orchestrator/backend/services/rag/search.py:43:14
   |
41 |     """Réponse complète d'une recherche"""
42 |     query: str
43 |     results: List[SearchResult]
   |              ^^^^
44 |     total_found: int
45 |     search_time_ms: float
   |
help: Replace with `list`

UP045 [*] Use `X | None` for type annotations
  --> ai-orchestrator/backend/services/rag/search.py:64:17
   |
62 |     def __init__(
63 |         self,
64 |         config: Optional[RAGConfig] = None,
   |                 ^^^^^^^^^^^^^^^^^^^
65 |         embedding_service: Optional[EmbeddingService] = None,
66 |         reranker_service: Optional[RerankerService] = None
   |
help: Convert to `X | None`

UP045 [*] Use `X | None` for type annotations
  --> ai-orchestrator/backend/services/rag/search.py:65:28
   |
63 |         self,
64 |         config: Optional[RAGConfig] = None,
65 |         embedding_service: Optional[EmbeddingService] = None,
   |                            ^^^^^^^^^^^^^^^^^^^^^^^^^^
66 |         reranker_service: Optional[RerankerService] = None
67 |     ):
   |
help: Convert to `X | None`

UP045 [*] Use `X | None` for type annotations
  --> ai-orchestrator/backend/services/rag/search.py:66:27
   |
64 |         config: Optional[RAGConfig] = None,
65 |         embedding_service: Optional[EmbeddingService] = None,
66 |         reranker_service: Optional[RerankerService] = None
   |                           ^^^^^^^^^^^^^^^^^^^^^^^^^
67 |     ):
68 |         self.config = config or get_rag_config()
   |
help: Convert to `X | None`

UP045 [*] Use `X | None` for type annotations
  --> ai-orchestrator/backend/services/rag/search.py:71:23
   |
69 |         self._embedding_service = embedding_service
70 |         self._reranker_service = reranker_service
71 |         self._client: Optional[httpx.AsyncClient] = None
   |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^
72 |         self._collection_id: Optional[str] = None
73 |         self._total_searches = 0
   |
help: Convert to `X | None`

UP045 [*] Use `X | None` for type annotations
  --> ai-orchestrator/backend/services/rag/search.py:72:30
   |
70 |         self._reranker_service = reranker_service
71 |         self._client: Optional[httpx.AsyncClient] = None
72 |         self._collection_id: Optional[str] = None
   |                              ^^^^^^^^^^^^^
73 |         self._total_searches = 0
   |
help: Convert to `X | None`

UP045 [*] Use `X | None` for type annotations
  --> ai-orchestrator/backend/services/rag/search.py:93:43
   |
91 |         return self._client
92 |     
93 |     async def _get_collection_id(self) -> Optional[str]:
   |                                           ^^^^^^^^^^^^^
94 |         """Récupère l'ID de la collection ChromaDB"""
95 |         if self._collection_id:
   |
help: Convert to `X | None`

UP006 [*] Use `list` instead of `List` for type annotation
   --> ai-orchestrator/backend/services/rag/search.py:117:26
    |
115 |     async def _search_chromadb(
116 |         self,
117 |         query_embedding: List[float],
    |                          ^^^^
118 |         n_results: int = 20
119 |     ) -> List[Tuple[str, Dict, float]]:
    |
help: Replace with `list`

UP006 [*] Use `list` instead of `List` for type annotation
   --> ai-orchestrator/backend/services/rag/search.py:119:10
    |
117 |         query_embedding: List[float],
118 |         n_results: int = 20
119 |     ) -> List[Tuple[str, Dict, float]]:
    |          ^^^^
120 |         """
121 |         Recherche dans ChromaDB par similarité vectorielle.
    |
help: Replace with `list`

UP006 [*] Use `tuple` instead of `Tuple` for type annotation
   --> ai-orchestrator/backend/services/rag/search.py:119:15
    |
117 |         query_embedding: List[float],
118 |         n_results: int = 20
119 |     ) -> List[Tuple[str, Dict, float]]:
    |               ^^^^^
120 |         """
121 |         Recherche dans ChromaDB par similarité vectorielle.
    |
help: Replace with `tuple`

UP006 [*] Use `dict` instead of `Dict` for type annotation
   --> ai-orchestrator/backend/services/rag/search.py:119:26
    |
117 |         query_embedding: List[float],
118 |         n_results: int = 20
119 |     ) -> List[Tuple[str, Dict, float]]:
    |                          ^^^^
120 |         """
121 |         Recherche dans ChromaDB par similarité vectorielle.
    |
help: Replace with `dict`

B905 `zip()` without an explicit `strict=` parameter
   --> ai-orchestrator/backend/services/rag/search.py:153:36
    |
152 |             results = []
153 |             for doc, meta, dist in zip(documents, metadatas, distances):
    |                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
154 |                 results.append((doc, meta, dist))
    |
help: Add explicit value for parameter `strict=`

UP045 [*] Use `X | None` for type annotations
   --> ai-orchestrator/backend/services/rag/search.py:172:16
    |
170 |         self,
171 |         query: str,
172 |         top_k: Optional[int] = None,
    |                ^^^^^^^^^^^^^
173 |         use_reranking: bool = True,
174 |         topic_filter: Optional[str] = None
    |
help: Convert to `X | None`

UP045 [*] Use `X | None` for type annotations
   --> ai-orchestrator/backend/services/rag/search.py:174:23
    |
172 |         top_k: Optional[int] = None,
173 |         use_reranking: bool = True,
174 |         topic_filter: Optional[str] = None
    |                       ^^^^^^^^^^^^^
175 |     ) -> SearchResponse:
176 |         """
    |
help: Convert to `X | None`

UP045 [*] Use `X | None` for type annotations
   --> ai-orchestrator/backend/services/rag/search.py:298:20
    |
296 |         self,
297 |         query: str,
298 |         max_chars: Optional[int] = None
    |                    ^^^^^^^^^^^^^
299 |     ) -> Optional[str]:
300 |         """
    |
help: Convert to `X | None`

UP045 [*] Use `X | None` for type annotations
   --> ai-orchestrator/backend/services/rag/search.py:299:10
    |
297 |         query: str,
298 |         max_chars: Optional[int] = None
299 |     ) -> Optional[str]:
    |          ^^^^^^^^^^^^^
300 |         """
301 |         Obtient le contexte pertinent pour une requête.
    |
help: Convert to `X | None`

UP006 [*] Use `dict` instead of `Dict` for type annotation
   --> ai-orchestrator/backend/services/rag/search.py:346:24
    |
345 |     @property
346 |     def stats(self) -> Dict:
    |                        ^^^^
347 |         """Statistiques du service"""
348 |         return {
    |
help: Replace with `dict`

UP045 [*] Use `X | None` for type annotations
   --> ai-orchestrator/backend/services/rag/search.py:362:18
    |
361 | # Singleton
362 | _search_service: Optional[SearchService] = None
    |                  ^^^^^^^^^^^^^^^^^^^^^^^
    |
help: Convert to `X | None`

I001 [*] Import block is un-sorted or un-formatted
  --> ai-orchestrator/backend/services/rag/tests.py:7:1
   |
 5 |   """
 6 |
 7 | / import asyncio
 8 | | import sys
 9 | | from datetime import datetime
10 | |
11 | | # Configuration pour tests
12 | | import os
   | |_________^
13 |   os.environ.setdefault("CHROMADB_HOST", "chromadb")
14 |   os.environ.setdefault("OLLAMA_URL", "http://10.10.10.46:11434")
   |
help: Organize imports

I001 [*] Import block is un-sorted or un-formatted
  --> ai-orchestrator/backend/services/rag/tests.py:20:5
   |
18 |     """Test de la configuration"""
19 |     print("\n📋 Test Configuration...")
20 |     from services.rag.config import get_rag_config, RAGConfig
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
21 |     
22 |     config = get_rag_config()
   |
help: Organize imports

F401 [*] `services.rag.config.RAGConfig` imported but unused
  --> ai-orchestrator/backend/services/rag/tests.py:20:53
   |
18 |     """Test de la configuration"""
19 |     print("\n📋 Test Configuration...")
20 |     from services.rag.config import get_rag_config, RAGConfig
   |                                                     ^^^^^^^^^
21 |     
22 |     config = get_rag_config()
   |
help: Remove unused import: `services.rag.config.RAGConfig`

S101 Use of `assert` detected
  --> ai-orchestrator/backend/services/rag/tests.py:24:5
   |
22 |     config = get_rag_config()
23 |     
24 |     assert config.embedding_model == "bge-m3", f"Modèle incorrect: {config.embedding_model}"
   |     ^^^^^^
25 |     assert config.collection_name == "ai_orchestrator_memory_v3"
26 |     assert config.chunk_size_tokens == 768
   |

S101 Use of `assert` detected
  --> ai-orchestrator/backend/services/rag/tests.py:25:5
   |
24 |     assert config.embedding_model == "bge-m3", f"Modèle incorrect: {config.embedding_model}"
25 |     assert config.collection_name == "ai_orchestrator_memory_v3"
   |     ^^^^^^
26 |     assert config.chunk_size_tokens == 768
27 |     assert config.embedding_dimensions == 1024
   |

S101 Use of `assert` detected
  --> ai-orchestrator/backend/services/rag/tests.py:26:5
   |
24 |     assert config.embedding_model == "bge-m3", f"Modèle incorrect: {config.embedding_model}"
25 |     assert config.collection_name == "ai_orchestrator_memory_v3"
26 |     assert config.chunk_size_tokens == 768
   |     ^^^^^^
27 |     assert config.embedding_dimensions == 1024
   |

S101 Use of `assert` detected
  --> ai-orchestrator/backend/services/rag/tests.py:27:5
   |
25 |     assert config.collection_name == "ai_orchestrator_memory_v3"
26 |     assert config.chunk_size_tokens == 768
27 |     assert config.embedding_dimensions == 1024
   |     ^^^^^^
28 |     
29 |     print(f"  ✅ Modèle embedding: {config.embedding_model}")
   |

S101 Use of `assert` detected
  --> ai-orchestrator/backend/services/rag/tests.py:44:5
   |
42 |     # Test 1: Génération simple
43 |     result = await service.generate("Comment installer Docker sur Ubuntu?")
44 |     assert result is not None, "Embedding None"
   |     ^^^^^^
45 |     assert len(result.embedding) == 1024, f"Dimension incorrecte: {len(result.embedding)}"
46 |     assert result.model == "bge-m3"
   |

S101 Use of `assert` detected
  --> ai-orchestrator/backend/services/rag/tests.py:45:5
   |
43 |     result = await service.generate("Comment installer Docker sur Ubuntu?")
44 |     assert result is not None, "Embedding None"
45 |     assert len(result.embedding) == 1024, f"Dimension incorrecte: {len(result.embedding)}"
   |     ^^^^^^
46 |     assert result.model == "bge-m3"
47 |     print(f"  ✅ Embedding généré: {len(result.embedding)} dims, {result.generation_time_ms:.0f}ms")
   |

S101 Use of `assert` detected
  --> ai-orchestrator/backend/services/rag/tests.py:46:5
   |
44 |     assert result is not None, "Embedding None"
45 |     assert len(result.embedding) == 1024, f"Dimension incorrecte: {len(result.embedding)}"
46 |     assert result.model == "bge-m3"
   |     ^^^^^^
47 |     print(f"  ✅ Embedding généré: {len(result.embedding)} dims, {result.generation_time_ms:.0f}ms")
   |

S101 Use of `assert` detected
  --> ai-orchestrator/backend/services/rag/tests.py:51:5
   |
49 |     # Test 2: Cache
50 |     result2 = await service.generate("Comment installer Docker sur Ubuntu?")
51 |     assert result2.cached == True, "Cache non utilisé"
   |     ^^^^^^
52 |     print(f"  ✅ Cache hit: {result2.generation_time_ms:.0f}ms")
   |

E712 Avoid equality comparisons to `True`; use `result2.cached:` for truth checks
  --> ai-orchestrator/backend/services/rag/tests.py:51:12
   |
49 |     # Test 2: Cache
50 |     result2 = await service.generate("Comment installer Docker sur Ubuntu?")
51 |     assert result2.cached == True, "Cache non utilisé"
   |            ^^^^^^^^^^^^^^^^^^^^^^
52 |     print(f"  ✅ Cache hit: {result2.generation_time_ms:.0f}ms")
   |
help: Replace with `result2.cached`

S101 Use of `assert` detected
  --> ai-orchestrator/backend/services/rag/tests.py:56:5
   |
54 |     # Test 3: Stats
55 |     stats = service.stats
56 |     assert stats["total_generations"] >= 1
   |     ^^^^^^
57 |     print(f"  ✅ Stats: {stats['cache']['hit_rate']} hit rate")
   |

S101 Use of `assert` detected
  --> ai-orchestrator/backend/services/rag/tests.py:71:5
   |
69 |     # Test 1: Recherche simple
70 |     response = await service.search("Comment configurer Traefik?", top_k=3)
71 |     assert response is not None
   |     ^^^^^^
72 |     print(f"  ✅ Recherche: {len(response.results)} résultats en {response.search_time_ms:.0f}ms")
   |

E501 Line too long (103 > 100)
  --> ai-orchestrator/backend/services/rag/tests.py:79:101
   |
78 |     # Test 2: Avec reranking
79 |     response2 = await service.search("architecture serveur unified-stack", top_k=5, use_reranking=True)
   |                                                                                                     ^^^
80 |     print(f"  ✅ Avec reranking: {len(response2.results)} résultats, rerank={response2.used_reranking}")
   |

E501 Line too long (104 > 100)
  --> ai-orchestrator/backend/services/rag/tests.py:80:100
   |
78 |     # Test 2: Avec reranking
79 |     response2 = await service.search("architecture serveur unified-stack", top_k=5, use_reranking=True)
80 |     print(f"  ✅ Avec reranking: {len(response2.results)} résultats, rerank={response2.used_reranking}")
   |                                                                                                     ^^^^
81 |     
82 |     # Test 3: Recherche vide
   |

S101 Use of `assert` detected
   --> ai-orchestrator/backend/services/rag/tests.py:102:5
    |
100 |     # Test 2: Query courte (pas d'injection)
101 |     result2 = await injector.get_context_for_query("bonjour")
102 |     assert result2.injected == False, "Injection sur salutation"
    |     ^^^^^^
103 |     print(f"  ✅ Salutation ignorée: injected={result2.injected}")
    |

E712 Avoid equality comparisons to `False`; use `not result2.injected:` for false checks
   --> ai-orchestrator/backend/services/rag/tests.py:102:12
    |
100 |     # Test 2: Query courte (pas d'injection)
101 |     result2 = await injector.get_context_for_query("bonjour")
102 |     assert result2.injected == False, "Injection sur salutation"
    |            ^^^^^^^^^^^^^^^^^^^^^^^^^
103 |     print(f"  ✅ Salutation ignorée: injected={result2.injected}")
    |
help: Replace with `not result2.injected`

F541 [*] f-string without any placeholders
   --> ai-orchestrator/backend/services/rag/tests.py:114:15
    |
112 |         print(f"  ✅ Prompt enrichi: +{len(enriched) - len(system_prompt)} chars")
113 |     else:
114 |         print(f"  ⚠️ Pas de contexte pertinent trouvé")
    |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
115 |     
116 |     return True
    |
help: Remove extraneous `f` prefix

I001 [*] Import block is un-sorted or un-formatted
   --> ai-orchestrator/backend/services/rag/tests.py:147:5
    |
145 |     """Test du pipeline complet"""
146 |     print("\n🚀 Test Pipeline Complet...")
147 |     from services.rag import search_documents, inject_rag_context
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
148 |     
149 |     # Test 1: Recherche via fonction utilitaire
    |
help: Organize imports

E501 Line too long (106 > 100)
   --> ai-orchestrator/backend/services/rag/tests.py:155:101
    |
153 |     # Test 2: Injection via fonction utilitaire
154 |     prompt = "Tu es un assistant pour gérer un serveur Ubuntu."
155 |     enriched, result = await inject_rag_context(prompt, "Quelles sont les commandes pour gérer la stack?")
    |                                                                                                     ^^^^^^
156 |     
157 |     if result.injected:
    |

F541 [*] f-string without any placeholders
   --> ai-orchestrator/backend/services/rag/tests.py:160:15
    |
158 |         print(f"  ✅ inject_rag_context: {len(result.sources)} sources injectées")
159 |     else:
160 |         print(f"  ⚠️ Pas de contexte trouvé (score min non atteint)")
    |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
161 |     
162 |     return True
    |
help: Remove extraneous `f` prefix

I001 [*] Import block is un-sorted or un-formatted
  --> ai-orchestrator/backend/services/rag_service.py:15:1
   |
13 |   """
14 |
15 | / import asyncio
16 | | import os
17 | | from typing import Dict, List, Optional, Any
18 | | from dataclasses import dataclass
19 | | import httpx
20 | | import chromadb
21 | | from chromadb.config import Settings
22 | |
23 | | # Import du reranker
24 | | from services.reranker import rerank_documents, hybrid_search_with_rerank
   | |_________________________________________________________________________^
25 |
26 |   # Configuration
   |
help: Organize imports

UP035 `typing.Dict` is deprecated, use `dict` instead
  --> ai-orchestrator/backend/services/rag_service.py:17:1
   |
15 | import asyncio
16 | import os
17 | from typing import Dict, List, Optional, Any
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
18 | from dataclasses import dataclass
19 | import httpx
   |

UP035 `typing.List` is deprecated, use `list` instead
  --> ai-orchestrator/backend/services/rag_service.py:17:1
   |
15 | import asyncio
16 | import os
17 | from typing import Dict, List, Optional, Any
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
18 | from dataclasses import dataclass
19 | import httpx
   |

F401 [*] `services.reranker.hybrid_search_with_rerank` imported but unused
  --> ai-orchestrator/backend/services/rag_service.py:24:49
   |
23 | # Import du reranker
24 | from services.reranker import rerank_documents, hybrid_search_with_rerank
   |                                                 ^^^^^^^^^^^^^^^^^^^^^^^^^
25 |
26 | # Configuration
   |
help: Remove unused import: `services.reranker.hybrid_search_with_rerank`

UP006 [*] Use `list` instead of `List` for type annotation
  --> ai-orchestrator/backend/services/rag_service.py:44:16
   |
42 |     """Résultat d'une recherche RAG"""
43 |     query: str
44 |     documents: List[Dict]
   |                ^^^^
45 |     context: str
46 |     sources: List[str]
   |
help: Replace with `list`

UP006 [*] Use `dict` instead of `Dict` for type annotation
  --> ai-orchestrator/backend/services/rag_service.py:44:21
   |
42 |     """Résultat d'une recherche RAG"""
43 |     query: str
44 |     documents: List[Dict]
   |                     ^^^^
45 |     context: str
46 |     sources: List[str]
   |
help: Replace with `dict`

UP006 [*] Use `list` instead of `List` for type annotation
  --> ai-orchestrator/backend/services/rag_service.py:46:14
   |
44 |     documents: List[Dict]
45 |     context: str
46 |     sources: List[str]
   |              ^^^^
47 |     scores: List[float]
   |
help: Replace with `list`

UP006 [*] Use `list` instead of `List` for type annotation
  --> ai-orchestrator/backend/services/rag_service.py:47:13
   |
45 |     context: str
46 |     sources: List[str]
47 |     scores: List[float]
   |             ^^^^
   |
help: Replace with `list`

UP006 [*] Use `dict` instead of `Dict` for type annotation
  --> ai-orchestrator/backend/services/rag_service.py:56:32
   |
54 |         self.chroma_client = None
55 |         self.collection = None
56 |         self._embedding_cache: Dict[str, List[float]] = {}
   |                                ^^^^
57 |     
58 |     def _get_collection(self):
   |
help: Replace with `dict`

UP006 [*] Use `list` instead of `List` for type annotation
  --> ai-orchestrator/backend/services/rag_service.py:56:42
   |
54 |         self.chroma_client = None
55 |         self.collection = None
56 |         self._embedding_cache: Dict[str, List[float]] = {}
   |                                          ^^^^
57 |     
58 |     def _get_collection(self):
   |
help: Replace with `list`

UP045 [*] Use `X | None` for type annotations
  --> ai-orchestrator/backend/services/rag_service.py:79:49
   |
77 |         return self.collection
78 |     
79 |     async def get_embedding(self, text: str) -> Optional[List[float]]:
   |                                                 ^^^^^^^^^^^^^^^^^^^^^
80 |         """Obtenir l'embedding d'un texte via bge-m3"""
81 |         # Cache
   |
help: Convert to `X | None`

UP006 [*] Use `list` instead of `List` for type annotation
  --> ai-orchestrator/backend/services/rag_service.py:79:58
   |
77 |         return self.collection
78 |     
79 |     async def get_embedding(self, text: str) -> Optional[List[float]]:
   |                                                          ^^^^
80 |         """Obtenir l'embedding d'un texte via bge-m3"""
81 |         # Cache
   |
help: Replace with `list`

UP045 [*] Use `X | None` for type annotations
   --> ai-orchestrator/backend/services/rag_service.py:109:18
    |
107 |         top_k: int = RERANK_TOP_K,
108 |         use_reranker: bool = True,
109 |         filters: Optional[Dict] = None
    |                  ^^^^^^^^^^^^^^
110 |     ) -> RAGResult:
111 |         """
    |
help: Convert to `X | None`

UP006 [*] Use `dict` instead of `Dict` for type annotation
   --> ai-orchestrator/backend/services/rag_service.py:109:27
    |
107 |         top_k: int = RERANK_TOP_K,
108 |         use_reranker: bool = True,
109 |         filters: Optional[Dict] = None
    |                           ^^^^
110 |     ) -> RAGResult:
111 |         """
    |
help: Replace with `dict`

UP045 [*] Use `X | None` for type annotations
   --> ai-orchestrator/backend/services/rag_service.py:203:19
    |
201 |         self,
202 |         content: str,
203 |         metadata: Optional[Dict] = None,
    |                   ^^^^^^^^^^^^^^
204 |         doc_id: Optional[str] = None
205 |     ) -> bool:
    |
help: Convert to `X | None`

UP006 [*] Use `dict` instead of `Dict` for type annotation
   --> ai-orchestrator/backend/services/rag_service.py:203:28
    |
201 |         self,
202 |         content: str,
203 |         metadata: Optional[Dict] = None,
    |                            ^^^^
204 |         doc_id: Optional[str] = None
205 |     ) -> bool:
    |
help: Replace with `dict`

UP045 [*] Use `X | None` for type annotations
   --> ai-orchestrator/backend/services/rag_service.py:204:17
    |
202 |         content: str,
203 |         metadata: Optional[Dict] = None,
204 |         doc_id: Optional[str] = None
    |                 ^^^^^^^^^^^^^
205 |     ) -> bool:
206 |         """Ajouter un document à l'index"""
    |
help: Convert to `X | None`

UP006 [*] Use `dict` instead of `Dict` for type annotation
   --> ai-orchestrator/backend/services/rag_service.py:234:34
    |
232 |             return False
233 |     
234 |     async def get_stats(self) -> Dict[str, Any]:
    |                                  ^^^^
235 |         """Obtenir les statistiques de l'index"""
236 |         collection = self._get_collection()
    |
help: Replace with `dict`

UP045 [*] Use `X | None` for type annotations
   --> ai-orchestrator/backend/services/rag_service.py:251:15
    |
250 | # Instance singleton
251 | _rag_service: Optional[RAGService] = None
    |               ^^^^^^^^^^^^^^^^^^^^
    |
help: Convert to `X | None`

I001 [*] Import block is un-sorted or un-formatted
  --> ai-orchestrator/backend/services/reranker.py:7:1
   |
 5 |   """
 6 |
 7 | / import httpx
 8 | | import asyncio
 9 | | from typing import List, Dict, Tuple, Optional
10 | | import os
   | |_________^
11 |
12 |   OLLAMA_URL = os.getenv("OLLAMA_URL", "http://10.10.10.46:11434")
   |
help: Organize imports

UP035 `typing.List` is deprecated, use `list` instead
  --> ai-orchestrator/backend/services/reranker.py:9:1
   |
 7 | import httpx
 8 | import asyncio
 9 | from typing import List, Dict, Tuple, Optional
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
10 | import os
   |

UP035 `typing.Dict` is deprecated, use `dict` instead
  --> ai-orchestrator/backend/services/reranker.py:9:1
   |
 7 | import httpx
 8 | import asyncio
 9 | from typing import List, Dict, Tuple, Optional
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
10 | import os
   |

UP035 `typing.Tuple` is deprecated, use `tuple` instead
  --> ai-orchestrator/backend/services/reranker.py:9:1
   |
 7 | import httpx
 8 | import asyncio
 9 | from typing import List, Dict, Tuple, Optional
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
10 | import os
   |

F401 [*] `typing.Tuple` imported but unused
  --> ai-orchestrator/backend/services/reranker.py:9:32
   |
 7 | import httpx
 8 | import asyncio
 9 | from typing import List, Dict, Tuple, Optional
   |                                ^^^^^
10 | import os
   |
help: Remove unused import: `typing.Tuple`

UP006 [*] Use `dict` instead of `Dict` for type annotation
  --> ai-orchestrator/backend/services/reranker.py:16:18
   |
15 | # Cache pour éviter les appels répétés
16 | _reranker_cache: Dict[str, float] = {}
   |                  ^^^^
   |
help: Replace with `dict`

UP006 [*] Use `list` instead of `List` for type annotation
  --> ai-orchestrator/backend/services/reranker.py:58:16
   |
56 | async def rerank_documents(
57 |     query: str, 
58 |     documents: List[Dict], 
   |                ^^^^
59 |     top_k: int = 5,
60 |     score_threshold: float = 0.0
   |
help: Replace with `list`

UP006 [*] Use `dict` instead of `Dict` for type annotation
  --> ai-orchestrator/backend/services/reranker.py:58:21
   |
56 | async def rerank_documents(
57 |     query: str, 
58 |     documents: List[Dict], 
   |                     ^^^^
59 |     top_k: int = 5,
60 |     score_threshold: float = 0.0
   |
help: Replace with `dict`

UP006 [*] Use `list` instead of `List` for type annotation
  --> ai-orchestrator/backend/services/reranker.py:61:6
   |
59 |     top_k: int = 5,
60 |     score_threshold: float = 0.0
61 | ) -> List[Dict]:
   |      ^^^^
62 |     """
63 |     Rerank une liste de documents par pertinence.
   |
help: Replace with `list`

UP006 [*] Use `dict` instead of `Dict` for type annotation
  --> ai-orchestrator/backend/services/reranker.py:61:11
   |
59 |     top_k: int = 5,
60 |     score_threshold: float = 0.0
61 | ) -> List[Dict]:
   |           ^^^^
62 |     """
63 |     Rerank une liste de documents par pertinence.
   |
help: Replace with `dict`

B905 `zip()` without an explicit `strict=` parameter
  --> ai-orchestrator/backend/services/reranker.py:89:23
   |
87 |     scores = await asyncio.gather(*tasks)
88 |     
89 |     for doc, score in zip(documents, scores):
   |                       ^^^^^^^^^^^^^^^^^^^^^^
90 |         if score >= score_threshold:
91 |             doc_copy = doc.copy()
   |
help: Add explicit value for parameter `strict=`

UP006 [*] Use `list` instead of `List` for type annotation
   --> ai-orchestrator/backend/services/reranker.py:103:20
    |
101 | async def hybrid_search_with_rerank(
102 |     query: str,
103 |     dense_results: List[Dict],
    |                    ^^^^
104 |     sparse_results: Optional[List[Dict]] = None,
105 |     top_k: int = 5
    |
help: Replace with `list`

UP006 [*] Use `dict` instead of `Dict` for type annotation
   --> ai-orchestrator/backend/services/reranker.py:103:25
    |
101 | async def hybrid_search_with_rerank(
102 |     query: str,
103 |     dense_results: List[Dict],
    |                         ^^^^
104 |     sparse_results: Optional[List[Dict]] = None,
105 |     top_k: int = 5
    |
help: Replace with `dict`

UP045 [*] Use `X | None` for type annotations
   --> ai-orchestrator/backend/services/reranker.py:104:21
    |
102 |     query: str,
103 |     dense_results: List[Dict],
104 |     sparse_results: Optional[List[Dict]] = None,
    |                     ^^^^^^^^^^^^^^^^^^^^
105 |     top_k: int = 5
106 | ) -> List[Dict]:
    |
help: Convert to `X | None`

UP006 [*] Use `list` instead of `List` for type annotation
   --> ai-orchestrator/backend/services/reranker.py:104:30
    |
102 |     query: str,
103 |     dense_results: List[Dict],
104 |     sparse_results: Optional[List[Dict]] = None,
    |                              ^^^^
105 |     top_k: int = 5
106 | ) -> List[Dict]:
    |
help: Replace with `list`

UP006 [*] Use `dict` instead of `Dict` for type annotation
   --> ai-orchestrator/backend/services/reranker.py:104:35
    |
102 |     query: str,
103 |     dense_results: List[Dict],
104 |     sparse_results: Optional[List[Dict]] = None,
    |                                   ^^^^
105 |     top_k: int = 5
106 | ) -> List[Dict]:
    |
help: Replace with `dict`

UP006 [*] Use `list` instead of `List` for type annotation
   --> ai-orchestrator/backend/services/reranker.py:106:6
    |
104 |     sparse_results: Optional[List[Dict]] = None,
105 |     top_k: int = 5
106 | ) -> List[Dict]:
    |      ^^^^
107 |     """
108 |     Combine recherche dense et sparse, puis rerank.
    |
help: Replace with `list`

UP006 [*] Use `dict` instead of `Dict` for type annotation
   --> ai-orchestrator/backend/services/reranker.py:106:11
    |
104 |     sparse_results: Optional[List[Dict]] = None,
105 |     top_k: int = 5
106 | ) -> List[Dict]:
    |           ^^^^
107 |     """
108 |     Combine recherche dense et sparse, puis rerank.
    |
help: Replace with `dict`

E501 Line too long (132 > 100)
   --> ai-orchestrator/backend/services/reranker.py:155:101
    |
153 | …ntu?"
154 | …
155 | …nteneurisation. Pour l'installer sur Ubuntu, utilisez apt-get install docker.io"},
    |                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
156 | …programmation populaire pour le machine learning."},
157 | …écessite d'ajouter votre utilisateur au groupe docker avec usermod -aG docker $USER"},
    |

E501 Line too long (102 > 100)
   --> ai-orchestrator/backend/services/reranker.py:156:101
    |
154 | …     docs = [
155 | …         {"content": "Docker est un outil de conteneurisation. Pour l'installer sur Ubuntu, utilisez apt-get install docker.io"},
156 | …         {"content": "Python est un langage de programmation populaire pour le machine learning."},
    |                                                                                                   ^^
157 | …         {"content": "La configuration Docker nécessite d'ajouter votre utilisateur au groupe docker avec usermod -aG docker $USER"},
158 | …     ]
    |

E501 Line too long (136 > 100)
   --> ai-orchestrator/backend/services/reranker.py:157:101
    |
155 | …eneurisation. Pour l'installer sur Ubuntu, utilisez apt-get install docker.io"},
156 | …ogrammation populaire pour le machine learning."},
157 | …essite d'ajouter votre utilisateur au groupe docker avec usermod -aG docker $USER"},
    |                                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
158 | …
    |

E501 Line too long (115 > 100)
  --> ai-orchestrator/backend/services/self_healing.py:46:102
   |
44 |         if percent_used > 90:
45 |             issues.append(
46 |                 f"⚠️ Espace disque CRITIQUE: {percent_used:.1f}% utilisé. Nettoie les logs ou fichiers temporaires."
   |                                                                                                     ^^^^^^^^^^^^^^^
47 |             )
   |

S607 Starting a process with a partial executable path
  --> ai-orchestrator/backend/services/self_healing.py:51:34
   |
49 |         # 2. Vérifier Docker (si disponible)
50 |         try:
51 |             res = subprocess.run(["docker", "ps", "-q"], capture_output=True, text=True)
   |                                  ^^^^^^^^^^^^^^^^^^^^^^
52 |             if res.returncode != 0:
53 |                 issues.append("⚠️ Docker semble inaccessible ou arrêté.")
   |

S110 `try`-`except`-`pass` detected, consider logging the exception
  --> ai-orchestrator/backend/services/self_healing.py:54:9
   |
52 |               if res.returncode != 0:
53 |                   issues.append("⚠️ Docker semble inaccessible ou arrêté.")
54 | /         except Exception:
55 | |             pass  # Docker peut ne pas être installé
   | |________________^
56 |
57 |           # 3. Vérifier Charge Système (seuil élevé pour serveur AI)
   |

I001 [*] Import block is un-sorted or un-formatted
  --> ai-orchestrator/backend/tests/test_all_tools.py:6:1
   |
 4 |   """
 5 |
 6 | / import asyncio
 7 | | import json
 8 | | import time
 9 | | import pytest
10 | | from datetime import datetime
   | |_____________________________^
11 |
12 |   # Liste des paramètres pour les tests
   |
help: Organize imports

F401 [*] `asyncio` imported but unused
 --> ai-orchestrator/backend/tests/test_all_tools.py:6:8
  |
4 | """
5 |
6 | import asyncio
  |        ^^^^^^^
7 | import json
8 | import time
  |
help: Remove unused import: `asyncio`

F401 [*] `json` imported but unused
 --> ai-orchestrator/backend/tests/test_all_tools.py:7:8
  |
6 | import asyncio
7 | import json
  |        ^^^^
8 | import time
9 | import pytest
  |
help: Remove unused import: `json`

F401 [*] `datetime.datetime` imported but unused
  --> ai-orchestrator/backend/tests/test_all_tools.py:10:22
   |
 8 | import time
 9 | import pytest
10 | from datetime import datetime
   |                      ^^^^^^^^
11 |
12 | # Liste des paramètres pour les tests
   |
help: Remove unused import: `datetime.datetime`

S108 Probable insecure usage of temporary file or directory: "/tmp"
  --> ai-orchestrator/backend/tests/test_all_tools.py:17:29
   |
15 |     ("system_info", {}, ["système"], False),
16 |     ("disk_usage", {}, ["/"], False),
17 |     ("disk_usage", {"path": "/tmp"}, ["tmp"], False),
   |                             ^^^^^^
18 |     ("process_list", {}, [], False),
19 |     ("execute_command", {"command": "echo 'test123'"}, ["test123"], False),
   |

S108 Probable insecure usage of temporary file or directory: "/tmp/test_valid.py"
  --> ai-orchestrator/backend/tests/test_all_tools.py:38:29
   |
37 |     # Test write_file avec validation syntaxe
38 |     ("write_file", {"path": "/tmp/test_valid.py", "content": "def hello():\n    return 'world'"}, ["écrit"], False),
   |                             ^^^^^^^^^^^^^^^^^^^^
39 |     ("write_file", {"path": "/tmp/test_invalid.py", "content": "def broken(\n    return"}, [], True),
   |

E501 Line too long (116 > 100)
  --> ai-orchestrator/backend/tests/test_all_tools.py:38:101
   |
37 |     # Test write_file avec validation syntaxe
38 |     ("write_file", {"path": "/tmp/test_valid.py", "content": "def hello():\n    return 'world'"}, ["écrit"], False),
   |                                                                                                     ^^^^^^^^^^^^^^^^
39 |     ("write_file", {"path": "/tmp/test_invalid.py", "content": "def broken(\n    return"}, [], True),
   |

S108 Probable insecure usage of temporary file or directory: "/tmp/test_invalid.py"
  --> ai-orchestrator/backend/tests/test_all_tools.py:39:29
   |
37 |     # Test write_file avec validation syntaxe
38 |     ("write_file", {"path": "/tmp/test_valid.py", "content": "def hello():\n    return 'world'"}, ["écrit"], False),
39 |     ("write_file", {"path": "/tmp/test_invalid.py", "content": "def broken(\n    return"}, [], True),
   |                             ^^^^^^^^^^^^^^^^^^^^^^
40 |
41 |     # ========== OUTILS GIT ==========
   |

E501 Line too long (101 > 100)
  --> ai-orchestrator/backend/tests/test_all_tools.py:39:101
   |
37 |     # Test write_file avec validation syntaxe
38 |     ("write_file", {"path": "/tmp/test_valid.py", "content": "def hello():\n    return 'world'"}, ["écrit"], False),
39 |     ("write_file", {"path": "/tmp/test_invalid.py", "content": "def broken(\n    return"}, [], True),
   |                                                                                                     ^
40 |
41 |     # ========== OUTILS GIT ==========
   |

E501 Line too long (151 > 100)
  --> ai-orchestrator/backend/tests/test_all_tools.py:53:101
   |
52 | …
53 | … value for unit testing", "category": "test"}, ["stocké", "mémorisé", "déconnecté"], False),
   |                                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
54 | …False),
55 | …
   |

S101 Use of `assert` detected
  --> ai-orchestrator/backend/tests/test_all_tools.py:81:14
   |
79 |     except Exception as e:
80 |         if should_fail:
81 |              assert True
   |              ^^^^^^
82 |              return
83 |         else:
   |

F841 Local variable `elapsed` is assigned to but never used
  --> ai-orchestrator/backend/tests/test_all_tools.py:86:5
   |
84 |              pytest.fail(f"Tool execution failed unexpectedly: {e}")
85 |
86 |     elapsed = round((time.time() - start) * 1000, 2)
   |     ^^^^^^^
87 |
88 |     # Vérifier si c'est une erreur
   |
help: Remove assignment to unused variable `elapsed`

S101 Use of `assert` detected
  --> ai-orchestrator/backend/tests/test_all_tools.py:92:9
   |
91 |     if should_fail:
92 |         assert is_error, f"Tool {tool_name} should have failed but succeeded. Result: {result}"
   |         ^^^^^^
93 |     else:
94 |         assert not is_error, f"Tool {tool_name} failed. Result: {result}"
   |

S101 Use of `assert` detected
  --> ai-orchestrator/backend/tests/test_all_tools.py:94:9
   |
92 |         assert is_error, f"Tool {tool_name} should have failed but succeeded. Result: {result}"
93 |     else:
94 |         assert not is_error, f"Tool {tool_name} failed. Result: {result}"
   |         ^^^^^^
95 |         if expected_contains:
96 |             all_found = all(exp.lower() in result.lower() for exp in expected_contains)
   |

S101 Use of `assert` detected
  --> ai-orchestrator/backend/tests/test_all_tools.py:97:13
   |
95 |         if expected_contains:
96 |             all_found = all(exp.lower() in result.lower() for exp in expected_contains)
97 |             assert all_found, f"Expected content {expected_contains} not found in result: {result}"
   |             ^^^^^^
   |

S306 Use of insecure and deprecated function (`mktemp`)
  --> ai-orchestrator/backend/tests/test_auth.py:16:30
   |
15 | # Utiliser une DB temporaire pour les tests
16 | os.environ["AUTH_DB_PATH"] = tempfile.mktemp(suffix=".db")
   |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
17 |
18 | from auth import (
   |

S105 Possible hardcoded password assigned to: "password"
  --> ai-orchestrator/backend/tests/test_auth.py:40:20
   |
38 |     def test_hash_password(self):
39 |         """Hachage crée un hash différent du mot de passe"""
40 |         password = "mysecretpassword"
   |                    ^^^^^^^^^^^^^^^^^^
41 |         hashed = hash_password(password)
42 |         assert hashed != password
   |

S101 Use of `assert` detected
  --> ai-orchestrator/backend/tests/test_auth.py:42:9
   |
40 |         password = "mysecretpassword"
41 |         hashed = hash_password(password)
42 |         assert hashed != password
   |         ^^^^^^
43 |         assert "$" in hashed  # Format salt$hash
   |

S101 Use of `assert` detected
  --> ai-orchestrator/backend/tests/test_auth.py:43:9
   |
41 |         hashed = hash_password(password)
42 |         assert hashed != password
43 |         assert "$" in hashed  # Format salt$hash
   |         ^^^^^^
44 |
45 |     def test_verify_correct_password(self):
   |

S105 Possible hardcoded password assigned to: "password"
  --> ai-orchestrator/backend/tests/test_auth.py:47:20
   |
45 |     def test_verify_correct_password(self):
46 |         """Vérification d'un mot de passe correct"""
47 |         password = "mysecretpassword"
   |                    ^^^^^^^^^^^^^^^^^^
48 |         hashed = hash_password(password)
49 |         assert verify_password(password, hashed) is True
   |

S101 Use of `assert` detected
  --> ai-orchestrator/backend/tests/test_auth.py:49:9
   |
47 |         password = "mysecretpassword"
48 |         hashed = hash_password(password)
49 |         assert verify_password(password, hashed) is True
   |         ^^^^^^
50 |
51 |     def test_verify_incorrect_password(self):
   |

S105 Possible hardcoded password assigned to: "password"
  --> ai-orchestrator/backend/tests/test_auth.py:53:20
   |
51 |     def test_verify_incorrect_password(self):
52 |         """Vérification d'un mot de passe incorrect"""
53 |         password = "mysecretpassword"
   |                    ^^^^^^^^^^^^^^^^^^
54 |         hashed = hash_password(password)
55 |         assert verify_password("wrongpassword", hashed) is False
   |

S101 Use of `assert` detected
  --> ai-orchestrator/backend/tests/test_auth.py:55:9
   |
53 |         password = "mysecretpassword"
54 |         hashed = hash_password(password)
55 |         assert verify_password("wrongpassword", hashed) is False
   |         ^^^^^^
56 |
57 |     def test_different_hashes_for_same_password(self):
   |

S105 Possible hardcoded password assigned to: "password"
  --> ai-orchestrator/backend/tests/test_auth.py:59:20
   |
57 |     def test_different_hashes_for_same_password(self):
58 |         """Deux hachages du même mot de passe sont différents (salt)"""
59 |         password = "mysecretpassword"
   |                    ^^^^^^^^^^^^^^^^^^
60 |         hash1 = hash_password(password)
61 |         hash2 = hash_password(password)
   |

S101 Use of `assert` detected
  --> ai-orchestrator/backend/tests/test_auth.py:62:9
   |
60 |         hash1 = hash_password(password)
61 |         hash2 = hash_password(password)
62 |         assert hash1 != hash2
   |         ^^^^^^
63 |         # Mais les deux doivent vérifier
64 |         assert verify_password(password, hash1)
   |

S101 Use of `assert` detected
  --> ai-orchestrator/backend/tests/test_auth.py:64:9
   |
62 |         assert hash1 != hash2
63 |         # Mais les deux doivent vérifier
64 |         assert verify_password(password, hash1)
   |         ^^^^^^
65 |         assert verify_password(password, hash2)
   |

S101 Use of `assert` detected
  --> ai-orchestrator/backend/tests/test_auth.py:65:9
   |
63 |         # Mais les deux doivent vérifier
64 |         assert verify_password(password, hash1)
65 |         assert verify_password(password, hash2)
   |         ^^^^^^
   |

S101 Use of `assert` detected
  --> ai-orchestrator/backend/tests/test_auth.py:74:9
   |
72 |         """Création d'un token d'accès"""
73 |         token = create_access_token({"sub": "testuser", "scopes": ["read"]})
74 |         assert token is not None
   |         ^^^^^^
75 |         assert isinstance(token, str)
76 |         assert len(token) > 50
   |

S101 Use of `assert` detected
  --> ai-orchestrator/backend/tests/test_auth.py:75:9
   |
73 |         token = create_access_token({"sub": "testuser", "scopes": ["read"]})
74 |         assert token is not None
75 |         assert isinstance(token, str)
   |         ^^^^^^
76 |         assert len(token) > 50
   |

S101 Use of `assert` detected
  --> ai-orchestrator/backend/tests/test_auth.py:76:9
   |
74 |         assert token is not None
75 |         assert isinstance(token, str)
76 |         assert len(token) > 50
   |         ^^^^^^
77 |
78 |     def test_verify_valid_token(self):
   |

S101 Use of `assert` detected
  --> ai-orchestrator/backend/tests/test_auth.py:82:9
   |
80 |         token = create_access_token({"sub": "testuser", "scopes": ["read", "write"]})
81 |         data = verify_token(token)
82 |         assert data is not None
   |         ^^^^^^
83 |         assert data.username == "testuser"
84 |         assert "read" in data.scopes
   |

S101 Use of `assert` detected
  --> ai-orchestrator/backend/tests/test_auth.py:83:9
   |
81 |         data = verify_token(token)
82 |         assert data is not None
83 |         assert data.username == "testuser"
   |         ^^^^^^
84 |         assert "read" in data.scopes
85 |         assert "write" in data.scopes
   |

S101 Use of `assert` detected
  --> ai-orchestrator/backend/tests/test_auth.py:84:9
   |
82 |         assert data is not None
83 |         assert data.username == "testuser"
84 |         assert "read" in data.scopes
   |         ^^^^^^
85 |         assert "write" in data.scopes
   |

S101 Use of `assert` detected
  --> ai-orchestrator/backend/tests/test_auth.py:85:9
   |
83 |         assert data.username == "testuser"
84 |         assert "read" in data.scopes
85 |         assert "write" in data.scopes
   |         ^^^^^^
86 |
87 |     def test_verify_invalid_token(self):
   |

S101 Use of `assert` detected
  --> ai-orchestrator/backend/tests/test_auth.py:90:9
   |
88 |         """Vérification d'un token invalide"""
89 |         data = verify_token("invalid.token.here")
90 |         assert data is None
   |         ^^^^^^
91 |
92 |     def test_verify_tampered_token(self):
   |

S101 Use of `assert` detected
  --> ai-orchestrator/backend/tests/test_auth.py:98:9
   |
96 |         tampered = token[:-5] + "XXXXX"
97 |         data = verify_token(tampered)
98 |         assert data is None
   |         ^^^^^^
   |

S106 Possible hardcoded password assigned to argument: "password"
   --> ai-orchestrator/backend/tests/test_auth.py:112:44
    |
110 |         """Création d'un utilisateur"""
111 |         user = create_user(
112 |             UserCreate(username="newuser", password="password123", email="test@example.com")
    |                                            ^^^^^^^^^^^^^^^^^^^^^^
113 |         )
114 |         assert user.username == "newuser"
    |

S101 Use of `assert` detected
   --> ai-orchestrator/backend/tests/test_auth.py:114:9
    |
112 |             UserCreate(username="newuser", password="password123", email="test@example.com")
113 |         )
114 |         assert user.username == "newuser"
    |         ^^^^^^
115 |         assert user.email == "test@example.com"
    |

S101 Use of `assert` detected
   --> ai-orchestrator/backend/tests/test_auth.py:115:9
    |
113 |         )
114 |         assert user.username == "newuser"
115 |         assert user.email == "test@example.com"
    |         ^^^^^^
116 |
117 |     def test_get_user(self):
    |

S101 Use of `assert` detected
   --> ai-orchestrator/backend/tests/test_auth.py:121:9
    |
119 |         # L'admin est créé par défaut
120 |         user = get_user("admin")
121 |         assert user is not None
    |         ^^^^^^
122 |         assert user.username == "admin"
123 |         assert user.is_admin is True
    |

S101 Use of `assert` detected
   --> ai-orchestrator/backend/tests/test_auth.py:122:9
    |
120 |         user = get_user("admin")
121 |         assert user is not None
122 |         assert user.username == "admin"
    |         ^^^^^^
123 |         assert user.is_admin is True
    |

S101 Use of `assert` detected
   --> ai-orchestrator/backend/tests/test_auth.py:123:9
    |
121 |         assert user is not None
122 |         assert user.username == "admin"
123 |         assert user.is_admin is True
    |         ^^^^^^
124 |
125 |     def test_get_nonexistent_user(self):
    |

S101 Use of `assert` detected
   --> ai-orchestrator/backend/tests/test_auth.py:128:9
    |
126 |         """Récupération d'un utilisateur inexistant"""
127 |         user = get_user("nonexistent")
128 |         assert user is None
    |         ^^^^^^
129 |
130 |     def test_authenticate_user_success(self):
    |

S106 Possible hardcoded password assigned to argument: "password"
   --> ai-orchestrator/backend/tests/test_auth.py:133:53
    |
131 |         """Authentification réussie"""
132 |         # Créer un utilisateur
133 |         create_user(UserCreate(username="authtest", password="testpass123"))
    |                                                     ^^^^^^^^^^^^^^^^^^^^^^
134 |         # Authentifier
135 |         user = authenticate_user("authtest", "testpass123")
    |

S101 Use of `assert` detected
   --> ai-orchestrator/backend/tests/test_auth.py:136:9
    |
134 |         # Authentifier
135 |         user = authenticate_user("authtest", "testpass123")
136 |         assert user is not None
    |         ^^^^^^
137 |         assert user.username == "authtest"
    |

S101 Use of `assert` detected
   --> ai-orchestrator/backend/tests/test_auth.py:137:9
    |
135 |         user = authenticate_user("authtest", "testpass123")
136 |         assert user is not None
137 |         assert user.username == "authtest"
    |         ^^^^^^
138 |
139 |     def test_authenticate_user_wrong_password(self):
    |

S106 Possible hardcoded password assigned to argument: "password"
   --> ai-orchestrator/backend/tests/test_auth.py:141:54
    |
139 |     def test_authenticate_user_wrong_password(self):
140 |         """Authentification avec mauvais mot de passe"""
141 |         create_user(UserCreate(username="authtest2", password="correctpass"))
    |                                                      ^^^^^^^^^^^^^^^^^^^^^^
142 |         user = authenticate_user("authtest2", "wrongpass")
143 |         assert user is None
    |

S101 Use of `assert` detected
   --> ai-orchestrator/backend/tests/test_auth.py:143:9
    |
141 |         create_user(UserCreate(username="authtest2", password="correctpass"))
142 |         user = authenticate_user("authtest2", "wrongpass")
143 |         assert user is None
    |         ^^^^^^
144 |
145 |     def test_authenticate_nonexistent_user(self):
    |

S101 Use of `assert` detected
   --> ai-orchestrator/backend/tests/test_auth.py:148:9
    |
146 |         """Authentification d'un utilisateur inexistant"""
147 |         user = authenticate_user("nobody", "anypass")
148 |         assert user is None
    |         ^^^^^^
    |

S101 Use of `assert` detected
   --> ai-orchestrator/backend/tests/test_auth.py:162:9
    |
160 |         """Création d'une API key"""
161 |         key = create_api_key("test-key", user_id=1, scopes=["read"])
162 |         assert key is not None
    |         ^^^^^^
163 |         assert key.startswith("ak_")
164 |         assert len(key) > 40
    |

S101 Use of `assert` detected
   --> ai-orchestrator/backend/tests/test_auth.py:163:9
    |
161 |         key = create_api_key("test-key", user_id=1, scopes=["read"])
162 |         assert key is not None
163 |         assert key.startswith("ak_")
    |         ^^^^^^
164 |         assert len(key) > 40
    |

S101 Use of `assert` detected
   --> ai-orchestrator/backend/tests/test_auth.py:164:9
    |
162 |         assert key is not None
163 |         assert key.startswith("ak_")
164 |         assert len(key) > 40
    |         ^^^^^^
165 |
166 |     def test_verify_api_key(self):
    |

S101 Use of `assert` detected
   --> ai-orchestrator/backend/tests/test_auth.py:170:9
    |
168 |         key = create_api_key("verify-test", user_id=1, scopes=["read", "write"])
169 |         info = verify_api_key(key)
170 |         assert info is not None
    |         ^^^^^^
171 |         assert info["name"] == "verify-test"
172 |         assert "read" in info["scopes"]
    |

S101 Use of `assert` detected
   --> ai-orchestrator/backend/tests/test_auth.py:171:9
    |
169 |         info = verify_api_key(key)
170 |         assert info is not None
171 |         assert info["name"] == "verify-test"
    |         ^^^^^^
172 |         assert "read" in info["scopes"]
    |

S101 Use of `assert` detected
   --> ai-orchestrator/backend/tests/test_auth.py:172:9
    |
170 |         assert info is not None
171 |         assert info["name"] == "verify-test"
172 |         assert "read" in info["scopes"]
    |         ^^^^^^
173 |
174 |     def test_verify_invalid_api_key(self):
    |

S101 Use of `assert` detected
   --> ai-orchestrator/backend/tests/test_auth.py:177:9
    |
175 |         """Vérification d'une API key invalide"""
176 |         info = verify_api_key("ak_invalidkey12345")
177 |         assert info is None
    |         ^^^^^^
178 |
179 |     def test_verify_non_api_key_format(self):
    |

S101 Use of `assert` detected
   --> ai-orchestrator/backend/tests/test_auth.py:182:9
    |
180 |         """Vérification d'une clé sans le préfixe ak_"""
181 |         info = verify_api_key("notanapikey")
182 |         assert info is None
    |         ^^^^^^
    |

S101 Use of `assert` detected
   --> ai-orchestrator/backend/tests/test_auth.py:196:9
    |
194 |         """Les premières tentatives sont autorisées"""
195 |         allowed = check_login_rate_limit("ratetest", "192.168.1.1")
196 |         assert allowed is True
    |         ^^^^^^
197 |
198 |     def test_rate_limit_blocks_after_threshold(self):
    |

S101 Use of `assert` detected
   --> ai-orchestrator/backend/tests/test_auth.py:206:9
    |
204 |         # La 6ème devrait être bloquée
205 |         allowed = check_login_rate_limit("ratelimit_test", "192.168.1.100")
206 |         assert allowed is False
    |         ^^^^^^
207 |
208 |     def test_successful_login_doesnt_count(self):
    |

S101 Use of `assert` detected
   --> ai-orchestrator/backend/tests/test_auth.py:214:9
    |
213 |         allowed = check_login_rate_limit("successtest", "192.168.1.50")
214 |         assert allowed is True
    |         ^^^^^^
    |

S101 Use of `assert` detected
   --> ai-orchestrator/backend/tests/test_auth.py:223:9
    |
221 |         """L'admin a tous les scopes"""
222 |         user = get_user("admin")
223 |         assert user is not None
    |         ^^^^^^
224 |         assert "admin" in user.scopes
225 |         assert "read" in user.scopes
    |

S101 Use of `assert` detected
   --> ai-orchestrator/backend/tests/test_auth.py:224:9
    |
222 |         user = get_user("admin")
223 |         assert user is not None
224 |         assert "admin" in user.scopes
    |         ^^^^^^
225 |         assert "read" in user.scopes
226 |         assert "write" in user.scopes
    |

S101 Use of `assert` detected
   --> ai-orchestrator/backend/tests/test_auth.py:225:9
    |
223 |         assert user is not None
224 |         assert "admin" in user.scopes
225 |         assert "read" in user.scopes
    |         ^^^^^^
226 |         assert "write" in user.scopes
227 |         assert "execute" in user.scopes
    |

S101 Use of `assert` detected
   --> ai-orchestrator/backend/tests/test_auth.py:226:9
    |
224 |         assert "admin" in user.scopes
225 |         assert "read" in user.scopes
226 |         assert "write" in user.scopes
    |         ^^^^^^
227 |         assert "execute" in user.scopes
    |

S101 Use of `assert` detected
   --> ai-orchestrator/backend/tests/test_auth.py:227:9
    |
225 |         assert "read" in user.scopes
226 |         assert "write" in user.scopes
227 |         assert "execute" in user.scopes
    |         ^^^^^^
228 |
229 |     def test_new_user_has_read_scope(self):
    |

S106 Possible hardcoded password assigned to argument: "password"
   --> ai-orchestrator/backend/tests/test_auth.py:231:54
    |
229 |     def test_new_user_has_read_scope(self):
230 |         """Un nouvel utilisateur a le scope read par défaut"""
231 |         create_user(UserCreate(username="scopetest", password="password"))
    |                                                      ^^^^^^^^^^^^^^^^^^^
232 |         user = get_user("scopetest")
233 |         assert "read" in user.scopes
    |

S101 Use of `assert` detected
   --> ai-orchestrator/backend/tests/test_auth.py:233:9
    |
231 |         create_user(UserCreate(username="scopetest", password="password"))
232 |         user = get_user("scopetest")
233 |         assert "read" in user.scopes
    |         ^^^^^^
    |

I001 [*] Import block is un-sorted or un-formatted
  --> ai-orchestrator/backend/tests/test_full_system_check.py:7:1
   |
 5 |   """
 6 |
 7 | / import asyncio
 8 | | import logging
 9 | | import os
10 | | import sys
11 | | import pytest
12 | | from unittest.mock import MagicMock, patch
   | |__________________________________________^
13 |
14 |   # Setup path
   |
help: Organize imports

F401 [*] `asyncio` imported but unused
 --> ai-orchestrator/backend/tests/test_full_system_check.py:7:8
  |
5 | """
6 |
7 | import asyncio
  |        ^^^^^^^
8 | import logging
9 | import os
  |
help: Remove unused import: `asyncio`

S101 Use of `assert` detected
  --> ai-orchestrator/backend/tests/test_full_system_check.py:41:5
   |
39 |     logger.info(">> Test disk_usage('/')")
40 |     res = await execute_tool("disk_usage", {"path": "/"})
41 |     assert "Espace disque" in res or "%" in res or "total" in res.lower(), f"disk_usage failed: {res}"
   |     ^^^^^^
42 |     logger.info("✅ disk_usage: SUCCÈS")
   |

E501 Line too long (102 > 100)
  --> ai-orchestrator/backend/tests/test_full_system_check.py:41:101
   |
39 |     logger.info(">> Test disk_usage('/')")
40 |     res = await execute_tool("disk_usage", {"path": "/"})
41 |     assert "Espace disque" in res or "%" in res or "total" in res.lower(), f"disk_usage failed: {res}"
   |                                                                                                     ^^
42 |     logger.info("✅ disk_usage: SUCCÈS")
   |

E501 Line too long (101 > 100)
  --> ai-orchestrator/backend/tests/test_full_system_check.py:47:101
   |
45 |     logger.info(">> Test Injection: execute_command('echo safe; whoami')")
46 |     res = await execute_tool("execute_command", {"command": "echo safe; whoami"})
47 |     # On s'attend à ce que le ; soit traité comme du texte, ou que la commande échoue sécuritairement
   |                                                                                                     ^
48 |     assert ";" in res or "safe" in res, f"Injection protection check failed: {res}"
49 |     logger.info("✅ Protection Injection: SUCCÈS")
   |

S101 Use of `assert` detected
  --> ai-orchestrator/backend/tests/test_full_system_check.py:48:5
   |
46 |     res = await execute_tool("execute_command", {"command": "echo safe; whoami"})
47 |     # On s'attend à ce que le ; soit traité comme du texte, ou que la commande échoue sécuritairement
48 |     assert ";" in res or "safe" in res, f"Injection protection check failed: {res}"
   |     ^^^^^^
49 |     logger.info("✅ Protection Injection: SUCCÈS")
   |

E501 Line too long (124 > 100)
  --> ai-orchestrator/backend/tests/test_full_system_check.py:72:102
   |
70 |             logger.info(f"✅ Fait appris: {learned}")
71 |         else:
72 |             logger.warning(f"⚠️ Auto-Learn n'a rien détecté (peut être normal selon le modèle/logique). Résultat: {learned}")
   |                                                                                                     ^^^^^^^^^^^^^^^^^^^^^^^^
73 |             # On ne fail pas forcément ici car ça dépend de l'IA/Regex
   |

S101 Use of `assert` detected
   --> ai-orchestrator/backend/tests/test_full_system_check.py:103:9
    |
101 |         )
102 |
103 |         assert "L'espace disque est suffisant" in result, f"ReAct engine failed: {result}"
    |         ^^^^^^
104 |         logger.info("✅ Moteur ReAct: SUCCÈS")
    |

I001 [*] Import block is un-sorted or un-formatted
  --> ai-orchestrator/backend/tests/test_global.py:6:1
   |
 4 |   """
 5 |
 6 | / import asyncio
 7 | | import time
 8 | | import pytest
 9 | | from datetime import datetime
   | |_____________________________^
10 |
11 |   questions = [
   |
help: Organize imports

F401 [*] `datetime.datetime` imported but unused
  --> ai-orchestrator/backend/tests/test_global.py:9:22
   |
 7 | import time
 8 | import pytest
 9 | from datetime import datetime
   |                      ^^^^^^^^
10 |
11 | questions = [
   |
help: Remove unused import: `datetime.datetime`

E501 Line too long (107 > 100)
  --> ai-orchestrator/backend/tests/test_global.py:15:101
   |
13 |     "Quel est l'état actuel du système? Donne-moi les infos CPU, RAM et disque.",
14 |     # Question 2: Docker multi-outils
15 |     "Liste tous les conteneurs Docker et montre-moi les logs des 5 dernières lignes du conteneur backend.",
   |                                                                                                     ^^^^^^^
16 |     # Question 3: Analyse fichier + Git
17 |     "Lis le fichier /app/main.py et dis-moi combien de lignes il fait. Montre aussi le dernier commit git du projet.",
   |

E501 Line too long (118 > 100)
  --> ai-orchestrator/backend/tests/test_global.py:17:101
   |
15 |     "Liste tous les conteneurs Docker et montre-moi les logs des 5 dernières lignes du conteneur backend.",
16 |     # Question 3: Analyse fichier + Git
17 |     "Lis le fichier /app/main.py et dis-moi combien de lignes il fait. Montre aussi le dernier commit git du projet.",
   |                                                                                                     ^^^^^^^^^^^^^^^^^^
18 |     # Question 4: Réseau
19 |     "Vérifie si google.com est accessible et fais un ping vers 8.8.8.8. Donne-moi le temps de réponse.",
   |

E501 Line too long (104 > 100)
  --> ai-orchestrator/backend/tests/test_global.py:19:101
   |
17 |     "Lis le fichier /app/main.py et dis-moi combien de lignes il fait. Montre aussi le dernier commit git du projet.",
18 |     # Question 4: Réseau
19 |     "Vérifie si google.com est accessible et fais un ping vers 8.8.8.8. Donne-moi le temps de réponse.",
   |                                                                                                     ^^^^
20 |     # Question 5: Auto-amélioration
21 |     "Crée un nouvel outil appelé 'hello_test' qui retourne 'Hello from auto-created tool!', puis teste-le immédiatement.",
   |

E501 Line too long (122 > 100)
  --> ai-orchestrator/backend/tests/test_global.py:21:101
   |
19 |     "Vérifie si google.com est accessible et fais un ping vers 8.8.8.8. Donne-moi le temps de réponse.",
20 |     # Question 5: Auto-amélioration
21 |     "Crée un nouvel outil appelé 'hello_test' qui retourne 'Hello from auto-created tool!', puis teste-le immédiatement.",
   |                                                                                                     ^^^^^^^^^^^^^^^^^^^^^^
22 | ]
   |

S101 Use of `assert` detected
  --> ai-orchestrator/backend/tests/test_global.py:58:9
   |
57 |         # Simple assertion that we got a non-empty response
58 |         assert response and len(response) > 0
   |         ^^^^^^
59 |
60 |     except asyncio.TimeoutError:
   |

UP041 [*] Replace aliased errors with `TimeoutError`
  --> ai-orchestrator/backend/tests/test_global.py:60:12
   |
58 |         assert response and len(response) > 0
59 |
60 |     except asyncio.TimeoutError:
   |            ^^^^^^^^^^^^^^^^^^^^
61 |         print(f"⏱️ TIMEOUT après {timeout}s")
62 |         pytest.fail(f"Timeout after {timeout}s")
   |
help: Replace `asyncio.TimeoutError` with builtin `TimeoutError`

S101 Use of `assert` detected
  --> ai-orchestrator/backend/tests/test_p0_fixes.py:24:5
   |
23 |     # Tests
24 |     assert (
   |     ^^^^^^
25 |         add_message_with_validation("assistant", "")
26 |         == "❌ Erreur: Impossible de générer une réponse. Veuillez reformuler votre demande."
   |

S101 Use of `assert` detected
  --> ai-orchestrator/backend/tests/test_p0_fixes.py:28:5
   |
26 |         == "❌ Erreur: Impossible de générer une réponse. Veuillez reformuler votre demande."
27 |     ), "Empty string should be rejected"
28 |     assert (
   |     ^^^^^^
29 |         add_message_with_validation("assistant", "   ")
30 |         == "❌ Erreur: Impossible de générer une réponse. Veuillez reformuler votre demande."
   |

S101 Use of `assert` detected
  --> ai-orchestrator/backend/tests/test_p0_fixes.py:32:5
   |
30 |         == "❌ Erreur: Impossible de générer une réponse. Veuillez reformuler votre demande."
31 |     ), "Whitespace should be rejected"
32 |     assert add_message_with_validation("assistant", "Hello") == "Hello", "Valid content should pass"
   |     ^^^^^^
33 |     assert add_message_with_validation("user", "") == "", "User can be empty"
   |

S101 Use of `assert` detected
  --> ai-orchestrator/backend/tests/test_p0_fixes.py:33:5
   |
31 |     ), "Whitespace should be rejected"
32 |     assert add_message_with_validation("assistant", "Hello") == "Hello", "Valid content should pass"
33 |     assert add_message_with_validation("user", "") == "", "User can be empty"
   |     ^^^^^^
34 |
35 |     print("✅ P0-1: Test validation réponses vides PASSÉ")
   |

S101 Use of `assert` detected
  --> ai-orchestrator/backend/tests/test_p0_fixes.py:54:5
   |
52 |             successful_tool_results.append(f"{tool_name}: {result[:200]}")
53 |
54 |     assert len(successful_tool_results) == 3, (
   |     ^^^^^^
55 |         f"Expected 3 results, got {len(successful_tool_results)}"
56 |     )
   |

S101 Use of `assert` detected
  --> ai-orchestrator/backend/tests/test_p0_fixes.py:57:5
   |
55 |         f"Expected 3 results, got {len(successful_tool_results)}"
56 |     )
57 |     assert "docker_ps" in successful_tool_results[0], "docker_ps should be first"
   |     ^^^^^^
58 |     assert "uptime" in successful_tool_results[1], "uptime should be second"
59 |     print("✅ P0-2a: Test collecte résultats PASSÉ")
   |

S101 Use of `assert` detected
  --> ai-orchestrator/backend/tests/test_p0_fixes.py:58:5
   |
56 |     )
57 |     assert "docker_ps" in successful_tool_results[0], "docker_ps should be first"
58 |     assert "uptime" in successful_tool_results[1], "uptime should be second"
   |     ^^^^^^
59 |     print("✅ P0-2a: Test collecte résultats PASSÉ")
   |

S101 Use of `assert` detected
  --> ai-orchestrator/backend/tests/test_p0_fixes.py:74:5
   |
72 |         fallback = "❌ **Échec de traitement**"
73 |
74 |     assert "Limite d'itérations" in fallback, "Should contain limit message"
   |     ^^^^^^
75 |     assert "uptime" in fallback, "Should contain uptime result"
76 |     assert "docker_ps" in fallback, "Should contain docker_ps result"
   |

S101 Use of `assert` detected
  --> ai-orchestrator/backend/tests/test_p0_fixes.py:75:5
   |
74 |     assert "Limite d'itérations" in fallback, "Should contain limit message"
75 |     assert "uptime" in fallback, "Should contain uptime result"
   |     ^^^^^^
76 |     assert "docker_ps" in fallback, "Should contain docker_ps result"
77 |     print("✅ P0-2b: Test message fallback PASSÉ")
   |

S101 Use of `assert` detected
  --> ai-orchestrator/backend/tests/test_p0_fixes.py:76:5
   |
74 |     assert "Limite d'itérations" in fallback, "Should contain limit message"
75 |     assert "uptime" in fallback, "Should contain uptime result"
76 |     assert "docker_ps" in fallback, "Should contain docker_ps result"
   |     ^^^^^^
77 |     print("✅ P0-2b: Test message fallback PASSÉ")
   |

S101 Use of `assert` detected
  --> ai-orchestrator/backend/tests/test_p0_fixes.py:89:9
   |
87 |         think_content = assistant_text[think_match : think_match + 200]
88 |         think_found = True
89 |         assert "analyser" in think_content.lower(), "THINK content should contain analyser"
   |         ^^^^^^
90 |
91 |     assert think_found, "THINK should be found"
   |

S101 Use of `assert` detected
  --> ai-orchestrator/backend/tests/test_p0_fixes.py:91:5
   |
89 |         assert "analyser" in think_content.lower(), "THINK content should contain analyser"
90 |
91 |     assert think_found, "THINK should be found"
   |     ^^^^^^
92 |     print("✅ P0-3a: Test extraction THINK PASSÉ")
   |

S101 Use of `assert` detected
   --> ai-orchestrator/backend/tests/test_p0_fixes.py:104:9
    |
102 |         plan_content = assistant_text[plan_match : plan_match + 200]
103 |         plan_found = True
104 |         assert "uptime" in plan_content.lower(), "PLAN content should contain uptime"
    |         ^^^^^^
105 |
106 |     assert plan_found, "PLAN should be found"
    |

S101 Use of `assert` detected
   --> ai-orchestrator/backend/tests/test_p0_fixes.py:106:5
    |
104 |         assert "uptime" in plan_content.lower(), "PLAN content should contain uptime"
105 |
106 |     assert plan_found, "PLAN should be found"
    |     ^^^^^^
107 |     print("✅ P0-3b: Test extraction PLAN PASSÉ")
    |

S101 Use of `assert` detected
  --> ai-orchestrator/backend/tests/test_rate_limiter.py:38:9
   |
36 |         """Incrémentation d'une nouvelle clé"""
37 |         state = await storage.increment("test:key", window_seconds=60)
38 |         assert state.requests == 1
   |         ^^^^^^
39 |
40 |     @pytest.mark.asyncio
   |

S101 Use of `assert` detected
  --> ai-orchestrator/backend/tests/test_rate_limiter.py:45:9
   |
43 |         await storage.increment("test:key2", window_seconds=60)
44 |         state = await storage.increment("test:key2", window_seconds=60)
45 |         assert state.requests == 2
   |         ^^^^^^
46 |
47 |     @pytest.mark.asyncio
   |

S101 Use of `assert` detected
  --> ai-orchestrator/backend/tests/test_rate_limiter.py:51:9
   |
49 |         """Réinitialisation de la fenêtre après expiration"""
50 |         state1 = await storage.increment("test:window", window_seconds=1)
51 |         assert state1.requests == 1
   |         ^^^^^^
52 |
53 |         # Attendre que la fenêtre expire
   |

S101 Use of `assert` detected
  --> ai-orchestrator/backend/tests/test_rate_limiter.py:57:9
   |
56 |         state2 = await storage.increment("test:window", window_seconds=1)
57 |         assert state2.requests == 1  # Réinitialisé
   |         ^^^^^^
58 |
59 |     @pytest.mark.asyncio
   |

S101 Use of `assert` detected
  --> ai-orchestrator/backend/tests/test_rate_limiter.py:64:9
   |
62 |         await storage.increment("test:violation", window_seconds=60)
63 |         violations = await storage.add_violation("test:violation")
64 |         assert violations == 1
   |         ^^^^^^
65 |
66 |         violations = await storage.add_violation("test:violation")
   |

S101 Use of `assert` detected
  --> ai-orchestrator/backend/tests/test_rate_limiter.py:67:9
   |
66 |         violations = await storage.add_violation("test:violation")
67 |         assert violations == 2
   |         ^^^^^^
68 |
69 |     @pytest.mark.asyncio
   |

S101 Use of `assert` detected
  --> ai-orchestrator/backend/tests/test_rate_limiter.py:77:9
   |
76 |         is_banned = await storage.is_banned("test:ban")
77 |         assert is_banned is True
   |         ^^^^^^
78 |
79 |     @pytest.mark.asyncio
   |

S101 Use of `assert` detected
  --> ai-orchestrator/backend/tests/test_rate_limiter.py:83:9
   |
81 |         """Pas de ban initial"""
82 |         is_banned = await storage.is_banned("test:noban")
83 |         assert is_banned is False
   |         ^^^^^^
   |

S101 Use of `assert` detected
  --> ai-orchestrator/backend/tests/test_rate_limiter.py:98:9
   |
96 |         """Autorise sous la limite"""
97 |         result = await limiter.check("test:under", max_requests=10, window_seconds=60)
98 |         assert result.allowed is True
   |         ^^^^^^
99 |         assert result.remaining == 9
   |

S101 Use of `assert` detected
   --> ai-orchestrator/backend/tests/test_rate_limiter.py:99:9
    |
 97 |         result = await limiter.check("test:under", max_requests=10, window_seconds=60)
 98 |         assert result.allowed is True
 99 |         assert result.remaining == 9
    |         ^^^^^^
100 |
101 |     @pytest.mark.asyncio
    |

S101 Use of `assert` detected
   --> ai-orchestrator/backend/tests/test_rate_limiter.py:110:9
    |
108 |         # La 6ème doit être bloquée
109 |         result = await limiter.check("test:over", max_requests=5, window_seconds=60)
110 |         assert result.allowed is False
    |         ^^^^^^
111 |         assert result.remaining == 0
112 |         assert result.retry_after is not None
    |

S101 Use of `assert` detected
   --> ai-orchestrator/backend/tests/test_rate_limiter.py:111:9
    |
109 |         result = await limiter.check("test:over", max_requests=5, window_seconds=60)
110 |         assert result.allowed is False
111 |         assert result.remaining == 0
    |         ^^^^^^
112 |         assert result.retry_after is not None
    |

S101 Use of `assert` detected
   --> ai-orchestrator/backend/tests/test_rate_limiter.py:112:9
    |
110 |         assert result.allowed is False
111 |         assert result.remaining == 0
112 |         assert result.retry_after is not None
    |         ^^^^^^
113 |
114 |     @pytest.mark.asyncio
    |

S101 Use of `assert` detected
   --> ai-orchestrator/backend/tests/test_rate_limiter.py:121:9
    |
119 |         r3 = await limiter.check("test:remaining", max_requests=10, window_seconds=60)
120 |
121 |         assert r1.remaining == 9
    |         ^^^^^^
122 |         assert r2.remaining == 8
123 |         assert r3.remaining == 7
    |

S101 Use of `assert` detected
   --> ai-orchestrator/backend/tests/test_rate_limiter.py:122:9
    |
121 |         assert r1.remaining == 9
122 |         assert r2.remaining == 8
    |         ^^^^^^
123 |         assert r3.remaining == 7
    |

S101 Use of `assert` detected
   --> ai-orchestrator/backend/tests/test_rate_limiter.py:123:9
    |
121 |         assert r1.remaining == 9
122 |         assert r2.remaining == 8
123 |         assert r3.remaining == 7
    |         ^^^^^^
    |

S101 Use of `assert` detected
   --> ai-orchestrator/backend/tests/test_rate_limiter.py:131:9
    |
129 |     def test_localhost_whitelisted(self):
130 |         """localhost est whitelisté"""
131 |         assert is_ip_whitelisted("127.0.0.1") is True
    |         ^^^^^^
132 |
133 |     def test_ipv6_localhost_whitelisted(self):
    |

S101 Use of `assert` detected
   --> ai-orchestrator/backend/tests/test_rate_limiter.py:135:9
    |
133 |     def test_ipv6_localhost_whitelisted(self):
134 |         """::1 est whitelisté"""
135 |         assert is_ip_whitelisted("::1") is True
    |         ^^^^^^
136 |
137 |     def test_random_ip_not_whitelisted(self):
    |

S101 Use of `assert` detected
   --> ai-orchestrator/backend/tests/test_rate_limiter.py:139:9
    |
137 |     def test_random_ip_not_whitelisted(self):
138 |         """IP aléatoire non whitelistée"""
139 |         assert is_ip_whitelisted("8.8.8.8") is False
    |         ^^^^^^
140 |
141 |     def test_add_whitelist_ip(self):
    |

S101 Use of `assert` detected
   --> ai-orchestrator/backend/tests/test_rate_limiter.py:144:9
    |
142 |         """Ajout d'une IP à la whitelist"""
143 |         add_whitelist_ip("1.2.3.4")
144 |         assert is_ip_whitelisted("1.2.3.4") is True
    |         ^^^^^^
145 |
146 |     def test_local_network_whitelisted(self):
    |

S101 Use of `assert` detected
   --> ai-orchestrator/backend/tests/test_rate_limiter.py:149:9
    |
147 |         """Réseau local whitelisté (CIDR)"""
148 |         # 10.10.10.0/24 est dans la whitelist
149 |         assert is_ip_whitelisted("10.10.10.1") is True
    |         ^^^^^^
150 |         assert is_ip_whitelisted("10.10.10.100") is True
    |

S101 Use of `assert` detected
   --> ai-orchestrator/backend/tests/test_rate_limiter.py:150:9
    |
148 |         # 10.10.10.0/24 est dans la whitelist
149 |         assert is_ip_whitelisted("10.10.10.1") is True
150 |         assert is_ip_whitelisted("10.10.10.100") is True
    |         ^^^^^^
    |

S101 Use of `assert` detected
   --> ai-orchestrator/backend/tests/test_rate_limiter.py:159:9
    |
157 |         """Limite pour /api/chat"""
158 |         requests, window = get_rate_limit_for_path("/api/chat")
159 |         assert requests == 10
    |         ^^^^^^
160 |         assert window == 60
    |

S101 Use of `assert` detected
   --> ai-orchestrator/backend/tests/test_rate_limiter.py:160:9
    |
158 |         requests, window = get_rate_limit_for_path("/api/chat")
159 |         assert requests == 10
160 |         assert window == 60
    |         ^^^^^^
161 |
162 |     def test_login_endpoint_limit(self):
    |

S101 Use of `assert` detected
   --> ai-orchestrator/backend/tests/test_rate_limiter.py:165:9
    |
163 |         """Limite pour /api/auth/login"""
164 |         requests, window = get_rate_limit_for_path("/api/auth/login")
165 |         assert requests == 5
    |         ^^^^^^
166 |         assert window == 300
    |

S101 Use of `assert` detected
   --> ai-orchestrator/backend/tests/test_rate_limiter.py:166:9
    |
164 |         requests, window = get_rate_limit_for_path("/api/auth/login")
165 |         assert requests == 5
166 |         assert window == 300
    |         ^^^^^^
167 |
168 |     def test_default_limit(self):
    |

S101 Use of `assert` detected
   --> ai-orchestrator/backend/tests/test_rate_limiter.py:171:9
    |
169 |         """Limite par défaut"""
170 |         requests, window = get_rate_limit_for_path("/unknown/path")
171 |         assert requests == 60
    |         ^^^^^^
172 |         assert window == 60
    |

S101 Use of `assert` detected
   --> ai-orchestrator/backend/tests/test_rate_limiter.py:172:9
    |
170 |         requests, window = get_rate_limit_for_path("/unknown/path")
171 |         assert requests == 60
172 |         assert window == 60
    |         ^^^^^^
173 |
174 |     def test_configure_custom_limits(self):
    |

S101 Use of `assert` detected
   --> ai-orchestrator/backend/tests/test_rate_limiter.py:178:9
    |
176 |         configure_rate_limits({"/custom/path": (100, 120)})
177 |         requests, window = get_rate_limit_for_path("/custom/path")
178 |         assert requests == 100
    |         ^^^^^^
179 |         assert window == 120
    |

S101 Use of `assert` detected
   --> ai-orchestrator/backend/tests/test_rate_limiter.py:179:9
    |
177 |         requests, window = get_rate_limit_for_path("/custom/path")
178 |         assert requests == 100
179 |         assert window == 120
    |         ^^^^^^
    |

S101 Use of `assert` detected
   --> ai-orchestrator/backend/tests/test_rate_limiter.py:188:9
    |
186 |         """Résultat autorisé"""
187 |         result = RateLimitResult(allowed=True, remaining=5, reset_at=time.time() + 60)
188 |         assert result.allowed is True
    |         ^^^^^^
189 |         assert result.remaining == 5
190 |         assert result.retry_after is None
    |

S101 Use of `assert` detected
   --> ai-orchestrator/backend/tests/test_rate_limiter.py:189:9
    |
187 |         result = RateLimitResult(allowed=True, remaining=5, reset_at=time.time() + 60)
188 |         assert result.allowed is True
189 |         assert result.remaining == 5
    |         ^^^^^^
190 |         assert result.retry_after is None
    |

S101 Use of `assert` detected
   --> ai-orchestrator/backend/tests/test_rate_limiter.py:190:9
    |
188 |         assert result.allowed is True
189 |         assert result.remaining == 5
190 |         assert result.retry_after is None
    |         ^^^^^^
191 |
192 |     def test_blocked_result(self):
    |

S101 Use of `assert` detected
   --> ai-orchestrator/backend/tests/test_rate_limiter.py:197:9
    |
195 |             allowed=False, remaining=0, reset_at=time.time() + 60, retry_after=30
196 |         )
197 |         assert result.allowed is False
    |         ^^^^^^
198 |         assert result.remaining == 0
199 |         assert result.retry_after == 30
    |

S101 Use of `assert` detected
   --> ai-orchestrator/backend/tests/test_rate_limiter.py:198:9
    |
196 |         )
197 |         assert result.allowed is False
198 |         assert result.remaining == 0
    |         ^^^^^^
199 |         assert result.retry_after == 30
    |

S101 Use of `assert` detected
   --> ai-orchestrator/backend/tests/test_rate_limiter.py:199:9
    |
197 |         assert result.allowed is False
198 |         assert result.remaining == 0
199 |         assert result.retry_after == 30
    |         ^^^^^^
    |

S101 Use of `assert` detected
   --> ai-orchestrator/backend/tests/test_rate_limiter.py:222:9
    |
221 |         # Exactement 10 autorisées et 10 bloquées
222 |         assert allowed == 10
    |         ^^^^^^
223 |         assert blocked == 10
    |

S101 Use of `assert` detected
   --> ai-orchestrator/backend/tests/test_rate_limiter.py:223:9
    |
221 |         # Exactement 10 autorisées et 10 bloquées
222 |         assert allowed == 10
223 |         assert blocked == 10
    |         ^^^^^^
    |

S101 Use of `assert` detected
   --> ai-orchestrator/backend/tests/test_rate_limiter.py:241:9
    |
240 |         # 1000 vérifications en moins de 0.5 seconde
241 |         assert elapsed < 0.5, f"Too slow: {elapsed}s for 1000 checks"
    |         ^^^^^^
    |

F401 [*] `security.CommandNotAllowedError` imported but unused
  --> ai-orchestrator/backend/tests/test_security.py:15:5
   |
14 | from security import (
15 |     CommandNotAllowedError,
   |     ^^^^^^^^^^^^^^^^^^^^^^
16 |     PathNotAllowedError,
17 |     check_dangerous_patterns,
   |
help: Remove unused import

F401 [*] `security.sanitize_path` imported but unused
  --> ai-orchestrator/backend/tests/test_security.py:20:5
   |
18 |     extract_base_command,
19 |     is_path_allowed,
20 |     sanitize_path,
   |     ^^^^^^^^^^^^^
21 |     validate_command,
22 |     validate_path,
   |
help: Remove unused import

S101 Use of `assert` detected
  --> ai-orchestrator/backend/tests/test_security.py:41:13
   |
39 |         for cmd in commands:
40 |             allowed, reason = validate_command(cmd)
41 |             assert allowed, f"Command should be allowed: {cmd} (Reason: {reason})"
   |             ^^^^^^
42 |
43 |     def test_blocked_commands(self):
   |

S101 Use of `assert` detected
  --> ai-orchestrator/backend/tests/test_security.py:53:13
   |
51 |         for cmd in blocked_commands:
52 |             allowed, reason = validate_command(cmd)
53 |             assert not allowed, f"Command should be blocked: {cmd}"
   |             ^^^^^^
54 |
55 |     def test_unknown_command_blocked(self):
   |

S101 Use of `assert` detected
  --> ai-orchestrator/backend/tests/test_security.py:63:9
   |
61 |         allowed, reason = validate_command(cmd)
62 |         # En mode v5.1 autonome, c'est autorisé si pas blacklisté
63 |         assert allowed, f"Unknown command should be allowed in autonomous mode: {cmd}"
   |         ^^^^^^
64 |
65 |     def test_empty_command(self):
   |

S101 Use of `assert` detected
  --> ai-orchestrator/backend/tests/test_security.py:68:9
   |
66 |         """Une commande vide doit être refusée"""
67 |         allowed, reason = validate_command("")
68 |         assert not allowed
   |         ^^^^^^
69 |         assert "vide" in reason
   |

S101 Use of `assert` detected
  --> ai-orchestrator/backend/tests/test_security.py:69:9
   |
67 |         allowed, reason = validate_command("")
68 |         assert not allowed
69 |         assert "vide" in reason
   |         ^^^^^^
70 |
71 |     def test_command_injection_patterns(self):
   |

S101 Use of `assert` detected
  --> ai-orchestrator/backend/tests/test_security.py:81:13
   |
79 |         for cmd in injections:
80 |             allowed, reason = validate_command(cmd)
81 |             assert not allowed, f"Injection should be blocked: {cmd}"
   |             ^^^^^^
82 |
83 |     def test_extract_base_command(self):
   |

S101 Use of `assert` detected
  --> ai-orchestrator/backend/tests/test_security.py:94:13
   |
92 |         for cmd, expected in cases:
93 |             base = extract_base_command(cmd)
94 |             assert base == expected
   |             ^^^^^^
   |

S108 Probable insecure usage of temporary file or directory: "/tmp/temp_file"
   --> ai-orchestrator/backend/tests/test_security.py:104:13
    |
102 |         paths = [
103 |             "/data/file.txt",
104 |             "/tmp/temp_file",
    |             ^^^^^^^^^^^^^^^^
105 |             "/var/log/syslog",
106 |             "/etc/hosts",
    |

S101 Use of `assert` detected
   --> ai-orchestrator/backend/tests/test_security.py:110:13
    |
108 |         for path in paths:
109 |             allowed, reason = is_path_allowed(path, write=False)
110 |             assert allowed, f"Read path should be allowed: {path} (Reason: {reason})"
    |             ^^^^^^
111 |
112 |     def test_blocked_read_paths(self):
    |

S101 Use of `assert` detected
   --> ai-orchestrator/backend/tests/test_security.py:122:13
    |
120 |         for path in paths:
121 |             allowed, reason = is_path_allowed(path, write=False)
122 |             assert not allowed, f"Read path should be blocked: {path}"
    |             ^^^^^^
123 |
124 |     def test_allowed_write_paths(self):
    |

S108 Probable insecure usage of temporary file or directory: "/tmp/test.log"
   --> ai-orchestrator/backend/tests/test_security.py:128:13
    |
126 |         paths = [
127 |             "/data/output.json",
128 |             "/tmp/test.log",
    |             ^^^^^^^^^^^^^^^
129 |             "/home/lalpha/projets/new_file.py",
130 |         ]
    |

S101 Use of `assert` detected
   --> ai-orchestrator/backend/tests/test_security.py:133:13
    |
131 |         for path in paths:
132 |             allowed, reason = is_path_allowed(path, write=True)
133 |             assert allowed, f"Write path should be allowed: {path} (Reason: {reason})"
    |             ^^^^^^
134 |
135 |     def test_blocked_write_paths(self):
    |

S101 Use of `assert` detected
   --> ai-orchestrator/backend/tests/test_security.py:145:13
    |
143 |         for path in paths:
144 |             allowed, reason = is_path_allowed(path, write=True)
145 |             assert not allowed, f"Write path should be blocked: {path}"
    |             ^^^^^^
146 |
147 |     def test_path_traversal_blocked(self):
    |

S108 Probable insecure usage of temporary file or directory: "/tmp/../../root/secret"
   --> ai-orchestrator/backend/tests/test_security.py:151:13
    |
149 |         paths = [
150 |             "/data/../etc/passwd",
151 |             "/tmp/../../root/secret",
    |             ^^^^^^^^^^^^^^^^^^^^^^^^
152 |         ]
153 |         for path in paths:
    |

S101 Use of `assert` detected
   --> ai-orchestrator/backend/tests/test_security.py:170:13
    |
168 |         for cmd in patterns:
169 |             detected = check_dangerous_patterns(cmd)
170 |             assert detected is not None, f"Should detect dangerous pattern in: {cmd}"
    |             ^^^^^^
171 |
172 |     def test_safe_patterns_not_flagged(self):
    |

S101 Use of `assert` detected
   --> ai-orchestrator/backend/tests/test_security.py:180:13
    |
178 |         for cmd in safe_cmds:
179 |             detected = check_dangerous_patterns(cmd)
180 |             assert detected is None, f"Should NOT detect dangerous pattern in: {cmd}"
    |             ^^^^^^
    |

S101 Use of `assert` detected
   --> ai-orchestrator/backend/tests/test_security.py:198:9
    |
196 |             validate_command("ls -la")
197 |         duration = time.time() - start
198 |         assert duration < 1.0, "Validation should be fast (>1000 ops/sec)"
    |         ^^^^^^
    |

I001 [*] Import block is un-sorted or un-formatted
  --> ai-orchestrator/backend/tests/test_security_proof.py:7:1
   |
 5 |   """
 6 |
 7 | / import asyncio
 8 | | import os
 9 | | import sys
10 | | import pytest
   | |_____________^
11 |
12 |   # Ajouter le dossier parent au path pour importer les modules
   |
help: Organize imports

F401 [*] `asyncio` imported but unused
 --> ai-orchestrator/backend/tests/test_security_proof.py:7:8
  |
5 | """
6 |
7 | import asyncio
  |        ^^^^^^^
8 | import os
9 | import sys
  |
help: Remove unused import: `asyncio`

E501 Line too long (104 > 100)
  --> ai-orchestrator/backend/tests/test_security_proof.py:29:101
   |
27 |     # Analyse
28 |     # Si le système est sûr, 'whoami' n'est pas exécuté par le shell
29 |     # mais passé comme argument à echo (ou échoue car echo n'accepte pas ; comme séparateur sans shell).
   |                                                                                                     ^^^^
30 |     
31 |     current_user = os.getlogin()
   |

S101 Use of `assert` detected
  --> ai-orchestrator/backend/tests/test_security_proof.py:39:5
   |
37 |     is_vulnerable = current_user in output and "SAFE" in output and ";" not in output
38 |     
39 |     assert not is_vulnerable, "🚨 INJECTION RÉUSSIE ! Le système est VULNÉRABLE."
   |     ^^^^^^
40 |     
41 |     # On s'attend à ce que 'whoami' soit présent dans l'output de echo (comme texte)
   |

F401 `os` imported but unused
  --> ai-orchestrator/backend/tools/__init__.py:15:8
   |
13 | import inspect
14 | import logging
15 | import os
   |        ^^
16 | import sys
17 | from pathlib import Path
   |
help: Remove unused import: `os`

UP035 [*] Import from `collections.abc` instead: `Callable`
  --> ai-orchestrator/backend/tools/__init__.py:18:1
   |
16 | import sys
17 | from pathlib import Path
18 | from typing import Any, Callable, Dict, List, Optional
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
19 |
20 | logger = logging.getLogger(__name__)
   |
help: Import from `collections.abc`

UP035 `typing.Dict` is deprecated, use `dict` instead
  --> ai-orchestrator/backend/tools/__init__.py:18:1
   |
16 | import sys
17 | from pathlib import Path
18 | from typing import Any, Callable, Dict, List, Optional
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
19 |
20 | logger = logging.getLogger(__name__)
   |

UP035 `typing.List` is deprecated, use `list` instead
  --> ai-orchestrator/backend/tools/__init__.py:18:1
   |
16 | import sys
17 | from pathlib import Path
18 | from typing import Any, Callable, Dict, List, Optional
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
19 |
20 | logger = logging.getLogger(__name__)
   |

F401 `typing.Any` imported but unused
  --> ai-orchestrator/backend/tools/__init__.py:18:20
   |
16 | import sys
17 | from pathlib import Path
18 | from typing import Any, Callable, Dict, List, Optional
   |                    ^^^
19 |
20 | logger = logging.getLogger(__name__)
   |
help: Remove unused import

F401 `typing.Optional` imported but unused
  --> ai-orchestrator/backend/tools/__init__.py:18:47
   |
16 | import sys
17 | from pathlib import Path
18 | from typing import Any, Callable, Dict, List, Optional
   |                                               ^^^^^^^^
19 |
20 | logger = logging.getLogger(__name__)
   |
help: Remove unused import

UP006 [*] Use `dict` instead of `Dict` for type annotation
  --> ai-orchestrator/backend/tools/__init__.py:23:17
   |
22 | # Registre des handlers d'outils
23 | _tool_handlers: Dict[str, Callable] = {}
   |                 ^^^^
24 | _tool_metadata: Dict[str, dict] = {}  # Métadonnées des outils (description, params)
25 | _handlers_loaded = False
   |
help: Replace with `dict`

UP006 [*] Use `dict` instead of `Dict` for type annotation
  --> ai-orchestrator/backend/tools/__init__.py:24:17
   |
22 | # Registre des handlers d'outils
23 | _tool_handlers: Dict[str, Callable] = {}
24 | _tool_metadata: Dict[str, dict] = {}  # Métadonnées des outils (description, params)
   |                 ^^^^
25 | _handlers_loaded = False
   |
help: Replace with `dict`

UP006 [*] Use `list` instead of `List` for type annotation
   --> ai-orchestrator/backend/tools/__init__.py:181:32
    |
181 | def get_tools_definitions() -> List[dict]:
    |                                ^^^^
182 |     """Retourne les définitions des outils (dynamique)"""
183 |     _ensure_handlers_loaded()
    |
help: Replace with `list`

F811 Redefinition of unused `TOOLS_DEFINITIONS` from line 189
   --> ai-orchestrator/backend/tools/__init__.py:222:1
    |
221 | # Pour compatibilité avec l'ancien code
222 | TOOLS_DEFINITIONS = []
    | ^^^^^^^^^^^^^^^^^ `TOOLS_DEFINITIONS` redefined here
    |
   ::: ai-orchestrator/backend/tools/__init__.py:189:5
    |
187 | # Alias pour compatibilité
188 | @property
189 | def TOOLS_DEFINITIONS():
    |     ----------------- previous definition of `TOOLS_DEFINITIONS` here
190 |     return get_tools_definitions()
    |
help: Remove definition: `TOOLS_DEFINITIONS`

E501 Line too long (149 > 100)
   --> ai-orchestrator/backend/tools/ai_tools.py:189:101
    |
188 | …tc.
189 | …lité non implémentée. Utilisez execute_command avec curl pour des recherches spécifiques."
    |                                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |

UP015 [*] Unnecessary mode argument
  --> ai-orchestrator/backend/tools/file_tools.py:42:25
   |
40 |             return f"⚠️ Fichier trop volumineux ({file_size} octets). Utilisez head/tail."
41 |
42 |         with open(path, "r", encoding="utf-8", errors="replace") as f:
   |                         ^^^
43 |             content = f.read()
   |
help: Remove mode argument

E501 Line too long (119 > 100)
  --> ai-orchestrator/backend/tools/file_tools.py:86:100
   |
84 |                 ast.parse(content)
85 |             except SyntaxError as e:
86 |                 return f"❌ Erreur de syntaxe Python détectée. Fichier NON écrit.\nLigne {e.lineno}: {e.msg}\n{e.text}"
   |                                                                                                     ^^^^^^^^^^^^^^^^^^^
87 |             except Exception as e:
88 |                 return f"❌ Erreur de validation du code: {str(e)}"
   |

UP035 `typing.List` is deprecated, use `list` instead
  --> ai-orchestrator/backend/tools/memory_tools.py:14:1
   |
12 | import os
13 | from datetime import datetime
14 | from typing import List, Optional
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
15 |
16 | import httpx
   |

UP045 [*] Use `X | None` for type annotations
  --> ai-orchestrator/backend/tools/memory_tools.py:34:39
   |
34 | async def get_embedding(text: str) -> Optional[List[float]]:
   |                                       ^^^^^^^^^^^^^^^^^^^^^
35 |     """Obtenir embedding via Ollama (bge-m3 - 1024 dim)"""
36 |     try:
   |
help: Convert to `X | None`

UP006 [*] Use `list` instead of `List` for type annotation
  --> ai-orchestrator/backend/tools/memory_tools.py:34:48
   |
34 | async def get_embedding(text: str) -> Optional[List[float]]:
   |                                                ^^^^
35 |     """Obtenir embedding via Ollama (bge-m3 - 1024 dim)"""
36 |     try:
   |
help: Replace with `list`

I001 [*] Import block is un-sorted or un-formatted
  --> ai-orchestrator/backend/tools/meta_tools.py:7:1
   |
 5 |   """
 6 |
 7 | / import ast
 8 | | import os
 9 | | import re
10 | | from pathlib import Path
11 | |
12 | | from tools import (get_tool_names, get_tools_description, register_tool,
13 | |                    reload_tools)
   | |________________________________^
14 |
15 |   TOOLS_DIR = Path(__file__).parent
   |
help: Organize imports

E501 Line too long (112 > 100)
  --> ai-orchestrator/backend/tools/meta_tools.py:69:100
   |
68 |     if not re.match(r"^[a-z][a-z0-9_]*$", name):
69 |         return f"❌ Erreur: Le nom '{name}' doit être en snake_case (lettres minuscules, chiffres, underscores)"
   |                                                                                                     ^^^^^^^^^^^^
70 |
71 |     if not description:
   |

UP015 [*] Unnecessary mode argument
   --> ai-orchestrator/backend/tools/meta_tools.py:196:34
    |
194 |     for file_path in TOOLS_DIR.glob("*_tools.py"):
195 |         try:
196 |             with open(file_path, "r", encoding="utf-8") as f:
    |                                  ^^^
197 |                 content = f.read()
    |
help: Remove mode argument

S112 `try`-`except`-`continue` detected, consider logging the exception
   --> ai-orchestrator/backend/tools/meta_tools.py:206:9
    |
204 |   {content}
205 |   ```"""
206 | /         except Exception:
207 | |             continue
    | |____________________^
208 |
209 |       return f"❌ Outil '{name}' non trouvé dans les fichiers source."
    |

E501 Line too long (102 > 100)
   --> ai-orchestrator/backend/tools/meta_tools.py:214:101
    |
212 | @register_tool(
213 |     "delete_tool",
214 |     description="Supprimer un outil auto-généré (sécurité: ne peut pas supprimer les outils système)",
    |                                                                                                     ^^
215 |     parameters={"name": "str"},
216 | )
    |

E501 Line too long (116 > 100)
  --> ai-orchestrator/backend/tools/network_tools.py:69:101
   |
67 | async def ssh_udm(command: str) -> tuple:
68 |     """Exécuter une commande SSH sur l'UDM"""
69 |     ssh_cmd = f"ssh -i {SSH_KEY} -o StrictHostKeyChecking=no -o ConnectTimeout=10 {UDM_USER}@{UDM_HOST} '{command}'"
   |                                                                                                     ^^^^^^^^^^^^^^^^
70 |     return await run_command_async(ssh_cmd, timeout=30)
   |

E501 Line too long (138 > 100)
  --> ai-orchestrator/backend/tools/network_tools.py:89:101
   |
87 | … ou les commandes
88 | …
89 | …/dev/null | grep -o 'client_count.*' | head -1 || echo 'Info clients non disponible'"
   |                                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
90 | …
   |

E722 Do not use bare `except`
   --> ai-orchestrator/backend/tools/network_tools.py:158:5
    |
156 |     try:
157 |         count = min(int(count), 10)
158 |     except:
    |     ^^^^^^
159 |         count = 3
    |

E501 Line too long (113 > 100)
  --> ai-orchestrator/backend/tools/ollama_tools.py:15:101
   |
13 | USER = os.getenv("HOST_USER", "lalpha")
14 | KEY = "/root/.ssh/id_ed25519"
15 | SSH = f"ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -o LogLevel=ERROR -i {KEY} {USER}@{HOST}"
   |                                                                                                     ^^^^^^^^^^^^^
16 |
17 | OLLAMA_HOST = "localhost:11434"
   |

E501 Line too long (126 > 100)
   --> ai-orchestrator/backend/tools/ollama_tools.py:114:101
    |
113 |     # Utiliser l'API directement
114 |     cmd = f'curl -s http://{OLLAMA_HOST}/api/generate -d \'{{"model":"{model}","prompt":"{prompt_escaped}","stream":false}}\''
    |                                                                                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^
115 |     out, code = await ssh_cmd(cmd, 120)
    |

F401 [*] `asyncio` imported but unused
 --> ai-orchestrator/backend/tools/rag_tools.py:6:8
  |
4 | """
5 |
6 | import asyncio
  |        ^^^^^^^
7 | import logging
8 | from datetime import datetime
  |
help: Remove unused import: `asyncio`

F401 [*] `datetime.datetime` imported but unused
 --> ai-orchestrator/backend/tools/rag_tools.py:8:22
  |
6 | import asyncio
7 | import logging
8 | from datetime import datetime
  |                      ^^^^^^^^
9 | from typing import Any, Dict, List, Optional
  |
help: Remove unused import: `datetime.datetime`

UP035 `typing.Dict` is deprecated, use `dict` instead
  --> ai-orchestrator/backend/tools/rag_tools.py:9:1
   |
 7 | import logging
 8 | from datetime import datetime
 9 | from typing import Any, Dict, List, Optional
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
10 |
11 | from tools import register_tool
   |

UP035 `typing.List` is deprecated, use `list` instead
  --> ai-orchestrator/backend/tools/rag_tools.py:9:1
   |
 7 | import logging
 8 | from datetime import datetime
 9 | from typing import Any, Dict, List, Optional
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
10 |
11 | from tools import register_tool
   |

F401 [*] `typing.Any` imported but unused
  --> ai-orchestrator/backend/tools/rag_tools.py:9:20
   |
 7 | import logging
 8 | from datetime import datetime
 9 | from typing import Any, Dict, List, Optional
   |                    ^^^
10 |
11 | from tools import register_tool
   |
help: Remove unused import

F401 [*] `typing.Dict` imported but unused
  --> ai-orchestrator/backend/tools/rag_tools.py:9:25
   |
 7 | import logging
 8 | from datetime import datetime
 9 | from typing import Any, Dict, List, Optional
   |                         ^^^^
10 |
11 | from tools import register_tool
   |
help: Remove unused import

I001 [*] Import block is un-sorted or un-formatted
  --> ai-orchestrator/backend/tools/rag_tools.py:15:5
   |
13 |   # Import de l'architecture RAG v2.0
14 |   try:
15 | /     from services.rag import (
16 | |         get_search_service,
17 | |         get_indexer,
18 | |         search_documents,
19 | |         SearchResponse,
20 | |         get_rag_config,
21 | |     )
   | |_____^
22 |       RAG_V2_AVAILABLE = True
23 |   except ImportError:
   |
help: Organize imports

F401 `services.rag.search_documents` imported but unused; consider using `importlib.util.find_spec` to test for availability
  --> ai-orchestrator/backend/tools/rag_tools.py:18:9
   |
16 |         get_search_service,
17 |         get_indexer,
18 |         search_documents,
   |         ^^^^^^^^^^^^^^^^
19 |         SearchResponse,
20 |         get_rag_config,
   |
help: Remove unused import: `services.rag.search_documents`

UP045 [*] Use `X | None` for type annotations
  --> ai-orchestrator/backend/tools/rag_tools.py:64:19
   |
62 |     top_k: int = 5,
63 |     use_reranking: bool = True,
64 |     topic_filter: Optional[str] = None,
   |                   ^^^^^^^^^^^^^
65 |     **kwargs
66 | ) -> str:
   |
help: Convert to `X | None`

E501 Line too long (134 > 100)
  --> ai-orchestrator/backend/tools/rag_tools.py:91:102
   |
89 | …
90 | …sur {response.total_found} trouvés)",
91 | …mbed: {response.embedding_time_ms:.0f}ms, rerank: {response.rerank_time_ms:.0f}ms)",
   |                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
92 | …
93 | …
   |

E501 Line too long (103 > 100)
  --> ai-orchestrator/backend/tools/rag_tools.py:97:101
   |
95 |         for i, result in enumerate(response.results, 1):
96 |             score_pct = int(result.score * 100)
97 |             rerank_info = f", rerank: {int(result.rerank_score * 100)}%" if result.rerank_score else ""
   |                                                                                                     ^^^
98 |             
99 |             lines.append(f"**{i}. [{result.filename}]** ({score_pct}% pertinent{rerank_info})")
   |

UP006 [*] Use `list` instead of `List` for type annotation
   --> ai-orchestrator/backend/tools/rag_tools.py:192:15
    |
190 | async def rag_index_directory(
191 |     directory: str,
192 |     patterns: List[str] = None,
    |               ^^^^
193 |     force: bool = False,
194 |     **kwargs
    |
help: Replace with `list`

E501 Line too long (120 > 100)
   --> ai-orchestrator/backend/tools/rag_tools.py:212:101
    |
210 |             f"   Fichiers traités: {stats.total_files}\n"
211 |             f"   Chunks indexés: {stats.total_chunks}\n"
212 |             f"   Nouveaux: {stats.new_files} | Mis à jour: {stats.updated_files} | Inchangés: {stats.unchanged_files}\n"
    |                                                                                                     ^^^^^^^^^^^^^^^^^^^^
213 |             f"   Erreurs: {stats.errors}\n"
214 |             f"   Durée: {stats.duration_ms:.0f}ms"
    |

E501 Line too long (101 > 100)
   --> ai-orchestrator/backend/tools/rag_tools.py:224:101
    |
222 | @register_tool(
223 |     name="rag_stats",
224 |     description="Affiche les statistiques du système RAG: collection, embeddings, reranking, cache.",
    |                                                                                                     ^
225 |     parameters={
226 |         "type": "object",
    |

E501 Line too long (113 > 100)
   --> ai-orchestrator/backend/tools/rag_tools.py:251:101
    |
249 |             f"   Embedding: {config.embedding_model} ({config.embedding_dimensions} dim)",
250 |             f"   Reranker: {config.reranker_model}",
251 |             f"   Chunk size: {config.chunk_size_tokens} tokens, {config.chunk_overlap_percent*100:.0f}% overlap",
    |                                                                                                     ^^^^^^^^^^^^^
252 |             "",
253 |             "**Recherche:**",
    |

E501 Line too long (105 > 100)
   --> ai-orchestrator/backend/tools/rag_tools.py:260:101
    |
258 |             f"   Générations: {stats['embedding']['total_generations']}",
259 |             f"   Temps moyen: {stats['embedding']['avg_generation_time_ms']}ms",
260 |             f"   Cache: {stats['embedding']['cache']['size']}/{stats['embedding']['cache']['max_size']}",
    |                                                                                                     ^^^^^
261 |             f"   Hit rate: {stats['embedding']['cache']['hit_rate']}",
262 |             "",
    |

E501 Line too long (113 > 100)
  --> ai-orchestrator/backend/tools/system_tools.py:15:101
   |
13 | USER = os.getenv("HOST_USER", "lalpha")
14 | KEY = "/root/.ssh/id_ed25519"
15 | SSH = f"ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -o LogLevel=ERROR -i {KEY} {USER}@{HOST}"
   |                                                                                                     ^^^^^^^^^^^^^
16 |
17 | # Commandes qui DOIVENT être exécutées sur l'hôte (pas dans le conteneur)
   |

E501 Line too long (110 > 100)
   --> ai-orchestrator/backend/tools/system_tools.py:107:101
    |
106 | **Raison**: Cette commande est interdite pour des raisons de sécurité.
107 | **Suggestion**: Utilise une alternative plus sûre ou demande une explication à l'utilisateur sur le besoin."""
    |                                                                                                     ^^^^^^^^^^
108 |     out, code = await run(cmd, 120)
109 |     return f"{'✅' if code == 0 else '❌'} {cmd[:80]}\n{out[:5000]}"
    |

UP035 `typing.Dict` is deprecated, use `dict` instead
  --> ai-orchestrator/backend/utils/async_subprocess.py:10:1
   |
 8 | import asyncio
 9 | import logging
10 | from typing import Dict, Optional, Tuple
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
11 |
12 | logger = logging.getLogger(__name__)
   |

UP035 `typing.Tuple` is deprecated, use `tuple` instead
  --> ai-orchestrator/backend/utils/async_subprocess.py:10:1
   |
 8 | import asyncio
 9 | import logging
10 | from typing import Dict, Optional, Tuple
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
11 |
12 | logger = logging.getLogger(__name__)
   |

UP045 [*] Use `X | None` for type annotations
  --> ai-orchestrator/backend/utils/async_subprocess.py:18:10
   |
16 |     command,
17 |     timeout: int = 60,
18 |     cwd: Optional[str] = None,
   |          ^^^^^^^^^^^^^
19 |     env: Optional[Dict[str, str]] = None,
20 |     use_shell: bool = None,
   |
help: Convert to `X | None`

UP045 [*] Use `X | None` for type annotations
  --> ai-orchestrator/backend/utils/async_subprocess.py:19:10
   |
17 |     timeout: int = 60,
18 |     cwd: Optional[str] = None,
19 |     env: Optional[Dict[str, str]] = None,
   |          ^^^^^^^^^^^^^^^^^^^^^^^^
20 |     use_shell: bool = None,
21 | ) -> Tuple[str, int]:
   |
help: Convert to `X | None`

UP006 [*] Use `dict` instead of `Dict` for type annotation
  --> ai-orchestrator/backend/utils/async_subprocess.py:19:19
   |
17 |     timeout: int = 60,
18 |     cwd: Optional[str] = None,
19 |     env: Optional[Dict[str, str]] = None,
   |                   ^^^^
20 |     use_shell: bool = None,
21 | ) -> Tuple[str, int]:
   |
help: Replace with `dict`

UP006 [*] Use `tuple` instead of `Tuple` for type annotation
  --> ai-orchestrator/backend/utils/async_subprocess.py:21:6
   |
19 |     env: Optional[Dict[str, str]] = None,
20 |     use_shell: bool = None,
21 | ) -> Tuple[str, int]:
   |      ^^^^^
22 |     """
23 |     Exécute une commande shell de manière asynchrone.
   |
help: Replace with `tuple`

UP041 [*] Replace aliased errors with `TimeoutError`
  --> ai-orchestrator/backend/utils/async_subprocess.py:80:16
   |
78 |             return output or "(aucune sortie)", process.returncode or 0
79 |
80 |         except asyncio.TimeoutError:
   |                ^^^^^^^^^^^^^^^^^^^^
81 |             # Tuer le processus si timeout
82 |             try:
   |
help: Replace `asyncio.TimeoutError` with builtin `TimeoutError`

S110 `try`-`except`-`pass` detected, consider logging the exception
  --> ai-orchestrator/backend/utils/async_subprocess.py:85:13
   |
83 |                   process.kill()
84 |                   await process.wait()
85 | /             except Exception:
86 | |                 pass
   | |____________________^
87 |               logger.warning(f"Timeout ({timeout}s) pour: {command[:50]}...")
88 |               return f"⏱️ Commande interrompue après {timeout}s", -1
   |

UP006 [*] Use `dict` instead of `Dict` for type annotation
  --> ai-orchestrator/backend/utils/async_subprocess.py:95:43
   |
95 | async def run_multiple_commands(commands: Dict[str, str], timeout: int = 10) -> Dict[str, str]:
   |                                           ^^^^
96 |     """
97 |     Exécute plusieurs commandes en parallèle.
   |
help: Replace with `dict`

UP006 [*] Use `dict` instead of `Dict` for type annotation
  --> ai-orchestrator/backend/utils/async_subprocess.py:95:81
   |
95 | async def run_multiple_commands(commands: Dict[str, str], timeout: int = 10) -> Dict[str, str]:
   |                                                                                 ^^^^
96 |     """
97 |     Exécute plusieurs commandes en parallèle.
   |
help: Replace with `dict`

UP006 [*] Use `tuple` instead of `Tuple` for type annotation
   --> ai-orchestrator/backend/utils/async_subprocess.py:107:47
    |
105 |     """
106 |
107 |     async def run_one(name: str, cmd: str) -> Tuple[str, str]:
    |                                               ^^^^^
108 |         output, code = await run_command_async(cmd, timeout=timeout)
109 |         return name, output
    |
help: Replace with `tuple`

UP006 [*] Use `tuple` instead of `Tuple` for type annotation
   --> ai-orchestrator/backend/utils/async_subprocess.py:126:6
    |
124 | async def run_ssh_command(
125 |     host: str, command: str, key_path: str = None, user: str = "root", timeout: int = 30
126 | ) -> Tuple[str, int]:
    |      ^^^^^
127 |     """
128 |     Exécute une commande via SSH de manière asynchrone.
    |
help: Replace with `tuple`

Found 625 errors.
[*] 249 fixable with the `--fix` option (8 hidden fixes can be enabled with the `--unsafe-fixes` option).
